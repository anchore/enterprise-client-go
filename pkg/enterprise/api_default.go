/*
Anchore API

This is the Anchore API. Provides the external API for users of Anchore Enterprise.

API version: 2.0.0
Contact: dev@anchore.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package enterprise

import (
	"bytes"
<<<<<<< HEAD
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

=======
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)
>>>>>>> main

type DefaultApi interface {

	/*
	AddGithubConfiguration Method for AddGithubConfiguration

	Create a new GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddGithubConfigurationRequest
	*/
	AddGithubConfiguration(ctx context.Context) ApiAddGithubConfigurationRequest

	// AddGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddGithubConfigurationRequest
	*/
	AddGithubConfiguration(ctx _context.Context) ApiAddGithubConfigurationRequest

	// AddGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddGithubSelector Method for AddGithubSelector

	Add selector for mapping events for delivery to a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddGithubSelectorRequest
	*/
	AddGithubSelector(ctx context.Context, uuid string) ApiAddGithubSelectorRequest

	// AddGithubSelectorExecute executes the request
	//  @return NotificationSelector
	AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddGithubSelectorRequest
	*/
	AddGithubSelector(ctx _context.Context, uuid string) ApiAddGithubSelectorRequest

	// AddGithubSelectorExecute executes the request
	//  @return NotificationSelector
	AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddIdp Method for AddIdp

	Add a new Identity Provider to the system, with a specific name

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddIdpRequest
	*/
	AddIdp(ctx context.Context) ApiAddIdpRequest

	// AddIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	AddIdpExecute(r ApiAddIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddIdpRequest
	*/
	AddIdp(ctx _context.Context) ApiAddIdpRequest

	// AddIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	AddIdpExecute(r ApiAddIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddJiraConfiguration Method for AddJiraConfiguration

	Create a new Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddJiraConfigurationRequest
	*/
	AddJiraConfiguration(ctx context.Context) ApiAddJiraConfigurationRequest

	// AddJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddJiraConfigurationRequest
	*/
	AddJiraConfiguration(ctx _context.Context) ApiAddJiraConfigurationRequest

	// AddJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddJiraSelector Method for AddJiraSelector

	Add selector for mapping events for delivery to a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddJiraSelectorRequest
	*/
	AddJiraSelector(ctx context.Context, uuid string) ApiAddJiraSelectorRequest

	// AddJiraSelectorExecute executes the request
	//  @return NotificationSelector
	AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddJiraSelectorRequest
	*/
	AddJiraSelector(ctx _context.Context, uuid string) ApiAddJiraSelectorRequest

	// AddJiraSelectorExecute executes the request
	//  @return NotificationSelector
	AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddRoleUser Add a user to the role

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiAddRoleUserRequest
	*/
	AddRoleUser(ctx context.Context, roleName string) ApiAddRoleUserRequest

	// AddRoleUserExecute executes the request
	//  @return RbacManagerRoleMember
	AddRoleUserExecute(r ApiAddRoleUserRequest) (*RbacManagerRoleMember, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param roleName
	 @return ApiAddRoleUserRequest
	*/
	AddRoleUser(ctx _context.Context, roleName string) ApiAddRoleUserRequest

	// AddRoleUserExecute executes the request
	//  @return RbacManagerRoleMember
	AddRoleUserExecute(r ApiAddRoleUserRequest) (RbacManagerRoleMember, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddSlackConfiguration Method for AddSlackConfiguration

	Create a new Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddSlackConfigurationRequest
	*/
	AddSlackConfiguration(ctx context.Context) ApiAddSlackConfigurationRequest

	// AddSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddSlackConfigurationRequest
	*/
	AddSlackConfiguration(ctx _context.Context) ApiAddSlackConfigurationRequest

	// AddSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddSlackSelector Method for AddSlackSelector

	Add selector for mapping events for delivery to a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddSlackSelectorRequest
	*/
	AddSlackSelector(ctx context.Context, uuid string) ApiAddSlackSelectorRequest

	// AddSlackSelectorExecute executes the request
	//  @return NotificationSelector
	AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddSlackSelectorRequest
	*/
	AddSlackSelector(ctx _context.Context, uuid string) ApiAddSlackSelectorRequest

	// AddSlackSelectorExecute executes the request
	//  @return NotificationSelector
	AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddSmtpConfiguration Method for AddSmtpConfiguration

	Create a new SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddSmtpConfigurationRequest
	*/
	AddSmtpConfiguration(ctx context.Context) ApiAddSmtpConfigurationRequest

	// AddSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddSmtpConfigurationRequest
	*/
	AddSmtpConfiguration(ctx _context.Context) ApiAddSmtpConfigurationRequest

	// AddSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddSmtpSelector Method for AddSmtpSelector

	Add selector for mapping events for delivery to a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddSmtpSelectorRequest
	*/
	AddSmtpSelector(ctx context.Context, uuid string) ApiAddSmtpSelectorRequest

	// AddSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddSmtpSelectorRequest
	*/
	AddSmtpSelector(ctx _context.Context, uuid string) ApiAddSmtpSelectorRequest

	// AddSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddTeamsConfiguration Method for AddTeamsConfiguration

	Create a new Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddTeamsConfigurationRequest
	*/
	AddTeamsConfiguration(ctx context.Context) ApiAddTeamsConfigurationRequest

	// AddTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddTeamsConfigurationRequest
	*/
	AddTeamsConfiguration(ctx _context.Context) ApiAddTeamsConfigurationRequest

	// AddTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddTeamsSelector Method for AddTeamsSelector

	Add selector for mapping events for delivery to a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddTeamsSelectorRequest
	*/
	AddTeamsSelector(ctx context.Context, uuid string) ApiAddTeamsSelectorRequest

	// AddTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddTeamsSelectorRequest
	*/
	AddTeamsSelector(ctx _context.Context, uuid string) ApiAddTeamsSelectorRequest

	// AddTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddWebhookConfiguration Method for AddWebhookConfiguration

	Create a new Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddWebhookConfigurationRequest
	*/
	AddWebhookConfiguration(ctx context.Context) ApiAddWebhookConfigurationRequest

	// AddWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiAddWebhookConfigurationRequest
	*/
	AddWebhookConfiguration(ctx _context.Context) ApiAddWebhookConfigurationRequest

	// AddWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	AddWebhookSelector Method for AddWebhookSelector

	Add selector for mapping events for delivery to a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddWebhookSelectorRequest
	*/
	AddWebhookSelector(ctx context.Context, uuid string) ApiAddWebhookSelectorRequest

	// AddWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiAddWebhookSelectorRequest
	*/
	AddWebhookSelector(ctx _context.Context, uuid string) ApiAddWebhookSelectorRequest

	// AddWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteGithubConfiguration Method for DeleteGithubConfiguration

	Delete a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteGithubConfigurationRequest
	*/
	DeleteGithubConfiguration(ctx context.Context, uuid string) ApiDeleteGithubConfigurationRequest

	// DeleteGithubConfigurationExecute executes the request
	DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteGithubConfigurationRequest
	*/
	DeleteGithubConfiguration(ctx _context.Context, uuid string) ApiDeleteGithubConfigurationRequest

	// DeleteGithubConfigurationExecute executes the request
	DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteGithubSelector Method for DeleteGithubSelector

	Delete a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteGithubSelectorRequest
	*/
	DeleteGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest

	// DeleteGithubSelectorExecute executes the request
	DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteGithubSelectorRequest
	*/
	DeleteGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest

	// DeleteGithubSelectorExecute executes the request
	DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteIdp Method for DeleteIdp

	Delete an idp configuration. Users will not longer be able to login from this idp. In addition, any users that have been configured explicitly or JIT Provisioned on this IDP will be deleted.

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiDeleteIdpRequest
	*/
	DeleteIdp(ctx context.Context, name string) ApiDeleteIdpRequest

	// DeleteIdpExecute executes the request
	DeleteIdpExecute(r ApiDeleteIdpRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiDeleteIdpRequest
	*/
	DeleteIdp(ctx _context.Context, name string) ApiDeleteIdpRequest

	// DeleteIdpExecute executes the request
	DeleteIdpExecute(r ApiDeleteIdpRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteJiraConfiguration Method for DeleteJiraConfiguration

	Delete a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteJiraConfigurationRequest
	*/
	DeleteJiraConfiguration(ctx context.Context, uuid string) ApiDeleteJiraConfigurationRequest

	// DeleteJiraConfigurationExecute executes the request
	DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteJiraConfigurationRequest
	*/
	DeleteJiraConfiguration(ctx _context.Context, uuid string) ApiDeleteJiraConfigurationRequest

	// DeleteJiraConfigurationExecute executes the request
	DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteJiraSelector Method for DeleteJiraSelector

	Delete a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteJiraSelectorRequest
	*/
	DeleteJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest

	// DeleteJiraSelectorExecute executes the request
	DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteJiraSelectorRequest
	*/
	DeleteJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest

	// DeleteJiraSelectorExecute executes the request
	DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteRoleUser Remove a user from the role

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiDeleteRoleUserRequest
	*/
	DeleteRoleUser(ctx context.Context, roleName string) ApiDeleteRoleUserRequest

	// DeleteRoleUserExecute executes the request
	DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param roleName
	 @return ApiDeleteRoleUserRequest
	*/
	DeleteRoleUser(ctx _context.Context, roleName string) ApiDeleteRoleUserRequest

	// DeleteRoleUserExecute executes the request
	DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteSlackConfiguration Method for DeleteSlackConfiguration

	Delete a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteSlackConfigurationRequest
	*/
	DeleteSlackConfiguration(ctx context.Context, uuid string) ApiDeleteSlackConfigurationRequest

	// DeleteSlackConfigurationExecute executes the request
	DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteSlackConfigurationRequest
	*/
	DeleteSlackConfiguration(ctx _context.Context, uuid string) ApiDeleteSlackConfigurationRequest

	// DeleteSlackConfigurationExecute executes the request
	DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteSlackSelector Method for DeleteSlackSelector

	Delete a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteSlackSelectorRequest
	*/
	DeleteSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest

	// DeleteSlackSelectorExecute executes the request
	DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteSlackSelectorRequest
	*/
	DeleteSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest

	// DeleteSlackSelectorExecute executes the request
	DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteSmtpConfiguration Method for DeleteSmtpConfiguration

	Delete a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteSmtpConfigurationRequest
	*/
	DeleteSmtpConfiguration(ctx context.Context, uuid string) ApiDeleteSmtpConfigurationRequest

	// DeleteSmtpConfigurationExecute executes the request
	DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteSmtpConfigurationRequest
	*/
	DeleteSmtpConfiguration(ctx _context.Context, uuid string) ApiDeleteSmtpConfigurationRequest

	// DeleteSmtpConfigurationExecute executes the request
	DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteSmtpSelector Method for DeleteSmtpSelector

	Delete a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteSmtpSelectorRequest
	*/
	DeleteSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest

	// DeleteSmtpSelectorExecute executes the request
	DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteSmtpSelectorRequest
	*/
	DeleteSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest

	// DeleteSmtpSelectorExecute executes the request
	DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteTeamsConfiguration Method for DeleteTeamsConfiguration

	Delete a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteTeamsConfigurationRequest
	*/
	DeleteTeamsConfiguration(ctx context.Context, uuid string) ApiDeleteTeamsConfigurationRequest

	// DeleteTeamsConfigurationExecute executes the request
	DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteTeamsConfigurationRequest
	*/
	DeleteTeamsConfiguration(ctx _context.Context, uuid string) ApiDeleteTeamsConfigurationRequest

	// DeleteTeamsConfigurationExecute executes the request
	DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteTeamsSelector Method for DeleteTeamsSelector

	Delete a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteTeamsSelectorRequest
	*/
	DeleteTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest

	// DeleteTeamsSelectorExecute executes the request
	DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteTeamsSelectorRequest
	*/
	DeleteTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest

	// DeleteTeamsSelectorExecute executes the request
	DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteWebhookConfiguration Method for DeleteWebhookConfiguration

	Delete a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteWebhookConfigurationRequest
	*/
	DeleteWebhookConfiguration(ctx context.Context, uuid string) ApiDeleteWebhookConfigurationRequest

	// DeleteWebhookConfigurationExecute executes the request
	DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiDeleteWebhookConfigurationRequest
	*/
	DeleteWebhookConfiguration(ctx _context.Context, uuid string) ApiDeleteWebhookConfigurationRequest

	// DeleteWebhookConfigurationExecute executes the request
	DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	DeleteWebhookSelector Method for DeleteWebhookSelector

	Delete a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteWebhookSelectorRequest
	*/
	DeleteWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest

	// DeleteWebhookSelectorExecute executes the request
	DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiDeleteWebhookSelectorRequest
	*/
	DeleteWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest

	// DeleteWebhookSelectorExecute executes the request
	DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	GetGithubConfiguration Method for GetGithubConfiguration

	Get a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetGithubConfigurationRequest
	*/
	GetGithubConfiguration(ctx context.Context, uuid string) ApiGetGithubConfigurationRequest

	// GetGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetGithubConfigurationRequest
	*/
	GetGithubConfiguration(ctx _context.Context, uuid string) ApiGetGithubConfigurationRequest

	// GetGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetGithubConfigurationStatus Method for GetGithubConfigurationStatus

	Get operational status for a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetGithubConfigurationStatusRequest
	*/
	GetGithubConfigurationStatus(ctx context.Context, uuid string) ApiGetGithubConfigurationStatusRequest

	// GetGithubConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetGithubConfigurationStatusRequest
	*/
	GetGithubConfigurationStatus(ctx _context.Context, uuid string) ApiGetGithubConfigurationStatusRequest

	// GetGithubConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetGithubSelector Method for GetGithubSelector

	Get a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetGithubSelectorRequest
	*/
	GetGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest

	// GetGithubSelectorExecute executes the request
	//  @return NotificationSelector
	GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetGithubSelectorRequest
	*/
	GetGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest

	// GetGithubSelectorExecute executes the request
	//  @return NotificationSelector
	GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetGlobalQueryResult Method for GetGlobalQueryResult

	Get a single saved global query result

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param resultUuid
	@return ApiGetGlobalQueryResultRequest
	*/
	GetGlobalQueryResult(ctx context.Context, resultUuid string) ApiGetGlobalQueryResultRequest

	// GetGlobalQueryResultExecute executes the request
	GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param resultUuid
	 @return ApiGetGlobalQueryResultRequest
	*/
	GetGlobalQueryResult(ctx _context.Context, resultUuid string) ApiGetGlobalQueryResultRequest

	// GetGlobalQueryResultExecute executes the request
	GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	GetIdp Method for GetIdp

	Return the configuration for a named Identity Provider

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiGetIdpRequest
	*/
	GetIdp(ctx context.Context, name string) ApiGetIdpRequest

	// GetIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	GetIdpExecute(r ApiGetIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiGetIdpRequest
	*/
	GetIdp(ctx _context.Context, name string) ApiGetIdpRequest

	// GetIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	GetIdpExecute(r ApiGetIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetJiraConfiguration Method for GetJiraConfiguration

	Get a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetJiraConfigurationRequest
	*/
	GetJiraConfiguration(ctx context.Context, uuid string) ApiGetJiraConfigurationRequest

	// GetJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetJiraConfigurationRequest
	*/
	GetJiraConfiguration(ctx _context.Context, uuid string) ApiGetJiraConfigurationRequest

	// GetJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetJiraConfigurationStatus Method for GetJiraConfigurationStatus

	Get operational status for a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetJiraConfigurationStatusRequest
	*/
	GetJiraConfigurationStatus(ctx context.Context, uuid string) ApiGetJiraConfigurationStatusRequest

	// GetJiraConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetJiraConfigurationStatusRequest
	*/
	GetJiraConfigurationStatus(ctx _context.Context, uuid string) ApiGetJiraConfigurationStatusRequest

	// GetJiraConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetJiraSelector Method for GetJiraSelector

	Get a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetJiraSelectorRequest
	*/
	GetJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest

	// GetJiraSelectorExecute executes the request
	//  @return NotificationSelector
	GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetJiraSelectorRequest
	*/
	GetJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest

	// GetJiraSelectorExecute executes the request
	//  @return NotificationSelector
	GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetOauthToken Method for GetOauthToken

	Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOauthTokenRequest
	*/
	GetOauthToken(ctx context.Context) ApiGetOauthTokenRequest

	// GetOauthTokenExecute executes the request
	//  @return TokenResponse
	GetOauthTokenExecute(r ApiGetOauthTokenRequest) (*TokenResponse, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiGetOauthTokenRequest
	*/
	GetOauthToken(ctx _context.Context) ApiGetOauthTokenRequest

	// GetOauthTokenExecute executes the request
	//  @return TokenResponse
	GetOauthTokenExecute(r ApiGetOauthTokenRequest) (TokenResponse, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetQueryResult Method for GetQueryResult

	Get a single saved query result

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param resultUuid
	@return ApiGetQueryResultRequest
	*/
	GetQueryResult(ctx context.Context, resultUuid string) ApiGetQueryResultRequest

	// GetQueryResultExecute executes the request
	GetQueryResultExecute(r ApiGetQueryResultRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param resultUuid
	 @return ApiGetQueryResultRequest
	*/
	GetQueryResult(ctx _context.Context, resultUuid string) ApiGetQueryResultRequest

	// GetQueryResultExecute executes the request
	GetQueryResultExecute(r ApiGetQueryResultRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	GetRole Get detailed information about a specific role

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiGetRoleRequest
	*/
	GetRole(ctx context.Context, roleName string) ApiGetRoleRequest

	// GetRoleExecute executes the request
	//  @return RbacManagerRole
	GetRoleExecute(r ApiGetRoleRequest) (*RbacManagerRole, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param roleName
	 @return ApiGetRoleRequest
	*/
	GetRole(ctx _context.Context, roleName string) ApiGetRoleRequest

	// GetRoleExecute executes the request
	//  @return RbacManagerRole
	GetRoleExecute(r ApiGetRoleRequest) (RbacManagerRole, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSlackConfiguration Method for GetSlackConfiguration

	Get a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSlackConfigurationRequest
	*/
	GetSlackConfiguration(ctx context.Context, uuid string) ApiGetSlackConfigurationRequest

	// GetSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetSlackConfigurationRequest
	*/
	GetSlackConfiguration(ctx _context.Context, uuid string) ApiGetSlackConfigurationRequest

	// GetSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSlackConfigurationStatus Method for GetSlackConfigurationStatus

	Get operational status for a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSlackConfigurationStatusRequest
	*/
	GetSlackConfigurationStatus(ctx context.Context, uuid string) ApiGetSlackConfigurationStatusRequest

	// GetSlackConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetSlackConfigurationStatusRequest
	*/
	GetSlackConfigurationStatus(ctx _context.Context, uuid string) ApiGetSlackConfigurationStatusRequest

	// GetSlackConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSlackSelector Method for GetSlackSelector

	Get a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetSlackSelectorRequest
	*/
	GetSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest

	// GetSlackSelectorExecute executes the request
	//  @return NotificationSelector
	GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetSlackSelectorRequest
	*/
	GetSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest

	// GetSlackSelectorExecute executes the request
	//  @return NotificationSelector
	GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSmtpConfiguration Method for GetSmtpConfiguration

	Get a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSmtpConfigurationRequest
	*/
	GetSmtpConfiguration(ctx context.Context, uuid string) ApiGetSmtpConfigurationRequest

	// GetSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetSmtpConfigurationRequest
	*/
	GetSmtpConfiguration(ctx _context.Context, uuid string) ApiGetSmtpConfigurationRequest

	// GetSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSmtpConfigurationStatus Method for GetSmtpConfigurationStatus

	Get operational status for a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSmtpConfigurationStatusRequest
	*/
	GetSmtpConfigurationStatus(ctx context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest

	// GetSmtpConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetSmtpConfigurationStatusRequest
	*/
	GetSmtpConfigurationStatus(ctx _context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest

	// GetSmtpConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetSmtpSelector Method for GetSmtpSelector

	Get a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetSmtpSelectorRequest
	*/
	GetSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest

	// GetSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetSmtpSelectorRequest
	*/
	GetSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest

	// GetSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetTeamsConfiguration Method for GetTeamsConfiguration

	Get a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetTeamsConfigurationRequest
	*/
	GetTeamsConfiguration(ctx context.Context, uuid string) ApiGetTeamsConfigurationRequest

	// GetTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetTeamsConfigurationRequest
	*/
	GetTeamsConfiguration(ctx _context.Context, uuid string) ApiGetTeamsConfigurationRequest

	// GetTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetTeamsConfigurationStatus Method for GetTeamsConfigurationStatus

	Get operational status for a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetTeamsConfigurationStatusRequest
	*/
	GetTeamsConfigurationStatus(ctx context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest

	// GetTeamsConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetTeamsConfigurationStatusRequest
	*/
	GetTeamsConfigurationStatus(ctx _context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest

	// GetTeamsConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetTeamsSelector Method for GetTeamsSelector

	Get a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetTeamsSelectorRequest
	*/
	GetTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest

	// GetTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetTeamsSelectorRequest
	*/
	GetTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest

	// GetTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetWebhookConfiguration Method for GetWebhookConfiguration

	Get a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetWebhookConfigurationRequest
	*/
	GetWebhookConfiguration(ctx context.Context, uuid string) ApiGetWebhookConfigurationRequest

	// GetWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetWebhookConfigurationRequest
	*/
	GetWebhookConfiguration(ctx _context.Context, uuid string) ApiGetWebhookConfigurationRequest

	// GetWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetWebhookConfigurationStatus Method for GetWebhookConfigurationStatus

	Get operational status for a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetWebhookConfigurationStatusRequest
	*/
	GetWebhookConfigurationStatus(ctx context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest

	// GetWebhookConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiGetWebhookConfigurationStatusRequest
	*/
	GetWebhookConfigurationStatus(ctx _context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest

	// GetWebhookConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	GetWebhookSelector Method for GetWebhookSelector

	Get a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetWebhookSelectorRequest
	*/
	GetWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest

	// GetWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiGetWebhookSelectorRequest
	*/
	GetWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest

	// GetWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	HealthCheck Method for HealthCheck

	Health check, returns 200 and no body if service is running

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthCheckRequest
	*/
	HealthCheck(ctx context.Context) ApiHealthCheckRequest

	// HealthCheckExecute executes the request
	HealthCheckExecute(r ApiHealthCheckRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiHealthCheckRequest
	*/
	HealthCheck(ctx _context.Context) ApiHealthCheckRequest

	// HealthCheckExecute executes the request
	HealthCheckExecute(r ApiHealthCheckRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	ListEndpoints Method for ListEndpoints

	List the system installed notification endpoints

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListEndpointsRequest
	*/
	ListEndpoints(ctx context.Context) ApiListEndpointsRequest

	// ListEndpointsExecute executes the request
	//  @return []NotificationEndpoint
	ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListEndpointsRequest
	*/
	ListEndpoints(ctx _context.Context) ApiListEndpointsRequest

	// ListEndpointsExecute executes the request
	//  @return []NotificationEndpoint
	ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListFileContentSearchResultsRequest
	*/
	ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest

	// ListFileContentSearchResultsExecute executes the request
	//  @return []FileContentSearchResult
	ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param imageDigest
	 @return ApiListFileContentSearchResultsRequest
	*/
	ListFileContentSearchResults(ctx _context.Context, imageDigest string) ApiListFileContentSearchResultsRequest

	// ListFileContentSearchResultsExecute executes the request
	//  @return []FileContentSearchResult
	ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListGithubConfigurations Method for ListGithubConfigurations

	List GitHub endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListGithubConfigurationsRequest
	*/
	ListGithubConfigurations(ctx context.Context) ApiListGithubConfigurationsRequest

	// ListGithubConfigurationsExecute executes the request
	//  @return []NotificationGitHubEndpointConfigurationBase
	ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListGithubConfigurationsRequest
	*/
	ListGithubConfigurations(ctx _context.Context) ApiListGithubConfigurationsRequest

	// ListGithubConfigurationsExecute executes the request
	//  @return []NotificationGitHubEndpointConfigurationBase
	ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListGithubSelectors Method for ListGithubSelectors

	List selectors mapping events for delivery to a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListGithubSelectorsRequest
	*/
	ListGithubSelectors(ctx context.Context, uuid string) ApiListGithubSelectorsRequest

	// ListGithubSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListGithubSelectorsRequest
	*/
	ListGithubSelectors(ctx _context.Context, uuid string) ApiListGithubSelectorsRequest

	// ListGithubSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListIdps Method for ListIdps

	List the names of configured Identity Providers for this anchore installation

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListIdpsRequest
	*/
	ListIdps(ctx context.Context) ApiListIdpsRequest

	// ListIdpsExecute executes the request
	//  @return []string
	ListIdpsExecute(r ApiListIdpsRequest) ([]string, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListIdpsRequest
	*/
	ListIdps(ctx _context.Context) ApiListIdpsRequest

	// ListIdpsExecute executes the request
	//  @return []string
	ListIdpsExecute(r ApiListIdpsRequest) ([]string, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListJiraConfigurations Method for ListJiraConfigurations

	List Jira endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListJiraConfigurationsRequest
	*/
	ListJiraConfigurations(ctx context.Context) ApiListJiraConfigurationsRequest

	// ListJiraConfigurationsExecute executes the request
	//  @return []NotificationJiraEndpointConfigurationBase
	ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListJiraConfigurationsRequest
	*/
	ListJiraConfigurations(ctx _context.Context) ApiListJiraConfigurationsRequest

	// ListJiraConfigurationsExecute executes the request
	//  @return []NotificationJiraEndpointConfigurationBase
	ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListJiraSelectors Method for ListJiraSelectors

	List selectors mapping events for delivery to a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListJiraSelectorsRequest
	*/
	ListJiraSelectors(ctx context.Context, uuid string) ApiListJiraSelectorsRequest

	// ListJiraSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListJiraSelectorsRequest
	*/
	ListJiraSelectors(ctx _context.Context, uuid string) ApiListJiraSelectorsRequest

	// ListJiraSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListRetrievedFiles Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListRetrievedFilesRequest
	*/
	ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest

	// ListRetrievedFilesExecute executes the request
	//  @return []RetrievedFile
	ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param imageDigest
	 @return ApiListRetrievedFilesRequest
	*/
	ListRetrievedFiles(ctx _context.Context, imageDigest string) ApiListRetrievedFilesRequest

	// ListRetrievedFilesExecute executes the request
	//  @return []RetrievedFile
	ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListRoleMembers Returns a list of objects that have members in the role. The list is filtered by 'listRoleMembers' access for the 'account' element of each entry.

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiListRoleMembersRequest
	*/
	ListRoleMembers(ctx context.Context, roleName string) ApiListRoleMembersRequest

	// ListRoleMembersExecute executes the request
	//  @return []RbacManagerRoleMember
	ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param roleName
	 @return ApiListRoleMembersRequest
	*/
	ListRoleMembers(ctx _context.Context, roleName string) ApiListRoleMembersRequest

	// ListRoleMembersExecute executes the request
	//  @return []RbacManagerRoleMember
	ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListRoles List roles available in the system

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListRolesRequest
	*/
	ListRoles(ctx context.Context) ApiListRolesRequest

	// ListRolesExecute executes the request
	//  @return []RbacManagerRoleSummary
	ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListRolesRequest
	*/
	ListRoles(ctx _context.Context) ApiListRolesRequest

	// ListRolesExecute executes the request
	//  @return []RbacManagerRoleSummary
	ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSecretSearchResults Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListSecretSearchResultsRequest
	*/
	ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest

	// ListSecretSearchResultsExecute executes the request
	//  @return []SecretSearchResult
	ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param imageDigest
	 @return ApiListSecretSearchResultsRequest
	*/
	ListSecretSearchResults(ctx _context.Context, imageDigest string) ApiListSecretSearchResultsRequest

	// ListSecretSearchResultsExecute executes the request
	//  @return []SecretSearchResult
	ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSelectors Method for ListSelectors

	List all selectors mapped to endpoint configurations for the account

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSelectorsRequest
	*/
	ListSelectors(ctx context.Context) ApiListSelectorsRequest

	// ListSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListSelectorsRequest
	*/
	ListSelectors(ctx _context.Context) ApiListSelectorsRequest

	// ListSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSlackConfigurations Method for ListSlackConfigurations

	List Slack endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSlackConfigurationsRequest
	*/
	ListSlackConfigurations(ctx context.Context) ApiListSlackConfigurationsRequest

	// ListSlackConfigurationsExecute executes the request
	//  @return []NotificationSlackEndpointConfiguration
	ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListSlackConfigurationsRequest
	*/
	ListSlackConfigurations(ctx _context.Context) ApiListSlackConfigurationsRequest

	// ListSlackConfigurationsExecute executes the request
	//  @return []NotificationSlackEndpointConfiguration
	ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSlackSelectors Method for ListSlackSelectors

	List selectors mapping events for delivery to a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListSlackSelectorsRequest
	*/
	ListSlackSelectors(ctx context.Context, uuid string) ApiListSlackSelectorsRequest

	// ListSlackSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListSlackSelectorsRequest
	*/
	ListSlackSelectors(ctx _context.Context, uuid string) ApiListSlackSelectorsRequest

	// ListSlackSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSmtpConfigurations Method for ListSmtpConfigurations

	List SMTP endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSmtpConfigurationsRequest
	*/
	ListSmtpConfigurations(ctx context.Context) ApiListSmtpConfigurationsRequest

	// ListSmtpConfigurationsExecute executes the request
	//  @return []NotificationSMTPEndpointConfiguration
	ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListSmtpConfigurationsRequest
	*/
	ListSmtpConfigurations(ctx _context.Context) ApiListSmtpConfigurationsRequest

	// ListSmtpConfigurationsExecute executes the request
	//  @return []NotificationSMTPEndpointConfiguration
	ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListSmtpSelectors Method for ListSmtpSelectors

	List selectors mapping events for delivery to a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListSmtpSelectorsRequest
	*/
	ListSmtpSelectors(ctx context.Context, uuid string) ApiListSmtpSelectorsRequest

	// ListSmtpSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListSmtpSelectorsRequest
	*/
	ListSmtpSelectors(ctx _context.Context, uuid string) ApiListSmtpSelectorsRequest

	// ListSmtpSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListTeamsConfigurations Method for ListTeamsConfigurations

	List Teams endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListTeamsConfigurationsRequest
	*/
	ListTeamsConfigurations(ctx context.Context) ApiListTeamsConfigurationsRequest

	// ListTeamsConfigurationsExecute executes the request
	//  @return []NotificationTeamsEndpointConfiguration
	ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListTeamsConfigurationsRequest
	*/
	ListTeamsConfigurations(ctx _context.Context) ApiListTeamsConfigurationsRequest

	// ListTeamsConfigurationsExecute executes the request
	//  @return []NotificationTeamsEndpointConfiguration
	ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListTeamsSelectors Method for ListTeamsSelectors

	List selectors mapping events for delivery to a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListTeamsSelectorsRequest
	*/
	ListTeamsSelectors(ctx context.Context, uuid string) ApiListTeamsSelectorsRequest

	// ListTeamsSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListTeamsSelectorsRequest
	*/
	ListTeamsSelectors(ctx _context.Context, uuid string) ApiListTeamsSelectorsRequest

	// ListTeamsSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListUserRoles List the roles for which the requested user is a member

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param username
	@return ApiListUserRolesRequest
	*/
	ListUserRoles(ctx context.Context, username string) ApiListUserRolesRequest

	// ListUserRolesExecute executes the request
	//  @return []RbacManagerRoleMembership
	ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param username
	 @return ApiListUserRolesRequest
	*/
	ListUserRoles(ctx _context.Context, username string) ApiListUserRolesRequest

	// ListUserRolesExecute executes the request
	//  @return []RbacManagerRoleMembership
	ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListWebhookConfigurations Method for ListWebhookConfigurations

	List Webhook endpoint configurations

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListWebhookConfigurationsRequest
	*/
	ListWebhookConfigurations(ctx context.Context) ApiListWebhookConfigurationsRequest

	// ListWebhookConfigurationsExecute executes the request
	//  @return []NotificationWebhookEndpointConfiguration
	ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListWebhookConfigurationsRequest
	*/
	ListWebhookConfigurations(ctx _context.Context) ApiListWebhookConfigurationsRequest

	// ListWebhookConfigurationsExecute executes the request
	//  @return []NotificationWebhookEndpointConfiguration
	ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	ListWebhookSelectors Method for ListWebhookSelectors

	List selectors mapping events for delivery to a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListWebhookSelectorsRequest
	*/
	ListWebhookSelectors(ctx context.Context, uuid string) ApiListWebhookSelectorsRequest

	// ListWebhookSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiListWebhookSelectorsRequest
	*/
	ListWebhookSelectors(ctx _context.Context, uuid string) ApiListWebhookSelectorsRequest

	// ListWebhookSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	MyRoles List the roles for which the authenticated user is a member

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMyRolesRequest
	*/
	MyRoles(ctx context.Context) ApiMyRolesRequest

	// MyRolesExecute executes the request
	//  @return []RbacManagerAccountRole
	MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiMyRolesRequest
	*/
	MyRoles(ctx _context.Context) ApiMyRolesRequest

	// MyRolesExecute executes the request
	//  @return []RbacManagerAccountRole
	MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *_nethttp.Response, error)
>>>>>>> main

	/*
	Ping Method for Ping

	Simple status check

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingRequest
	*/
	Ping(ctx context.Context) ApiPingRequest

	// PingExecute executes the request
	//  @return string
	PingExecute(r ApiPingRequest) (string, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiPingRequest
	*/
	Ping(ctx _context.Context) ApiPingRequest

	// PingExecute executes the request
	//  @return string
	PingExecute(r ApiPingRequest) (string, *_nethttp.Response, error)
>>>>>>> main

	/*
	RevokeOauthToken Method for RevokeOauthToken

	Revoke a refresh token previously requested from /oauth/token

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRevokeOauthTokenRequest
	*/
	RevokeOauthToken(ctx context.Context) ApiRevokeOauthTokenRequest

	// RevokeOauthTokenExecute executes the request
	RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiRevokeOauthTokenRequest
	*/
	RevokeOauthToken(ctx _context.Context) ApiRevokeOauthTokenRequest

	// RevokeOauthTokenExecute executes the request
	RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*_nethttp.Response, error)
>>>>>>> main

	/*
	SamlLogin Method for SamlLogin

	Initiate an SP-initiated login sequence for the Idp. The SP will respond with the SAML AuthN Request the client must send to the Idp URL

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idpName
	@return ApiSamlLoginRequest
	*/
	SamlLogin(ctx context.Context, idpName string) ApiSamlLoginRequest

	// SamlLoginExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlLoginExecute(r ApiSamlLoginRequest) (*RbacManagerTokenResponse, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param idpName
	 @return ApiSamlLoginRequest
	*/
	SamlLogin(ctx _context.Context, idpName string) ApiSamlLoginRequest

	// SamlLoginExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlLoginExecute(r ApiSamlLoginRequest) (RbacManagerTokenResponse, *_nethttp.Response, error)
>>>>>>> main

	/*
	SamlSso Method for SamlSso

	Perform a login using a SAML assertion, no HTTP auth is required as the SAML assertion is considered the authenticating token

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idpName
	@return ApiSamlSsoRequest
	*/
	SamlSso(ctx context.Context, idpName string) ApiSamlSsoRequest

	// SamlSsoExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlSsoExecute(r ApiSamlSsoRequest) (*RbacManagerTokenResponse, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param idpName
	 @return ApiSamlSsoRequest
	*/
	SamlSso(ctx _context.Context, idpName string) ApiSamlSsoRequest

	// SamlSsoExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlSsoExecute(r ApiSamlSsoRequest) (RbacManagerTokenResponse, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestGithubConfiguration Method for TestGithubConfiguration

	Test GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestGithubConfigurationRequest
	*/
	TestGithubConfiguration(ctx context.Context) ApiTestGithubConfigurationRequest

	// TestGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestGithubConfigurationRequest
	*/
	TestGithubConfiguration(ctx _context.Context) ApiTestGithubConfigurationRequest

	// TestGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (NotificationGitHubTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestJiraConfiguration Method for TestJiraConfiguration

	Test Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestJiraConfigurationRequest
	*/
	TestJiraConfiguration(ctx context.Context) ApiTestJiraConfigurationRequest

	// TestJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestJiraConfigurationRequest
	*/
	TestJiraConfiguration(ctx _context.Context) ApiTestJiraConfigurationRequest

	// TestJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (NotificationJiraTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestSlackConfiguration Method for TestSlackConfiguration

	Test Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestSlackConfigurationRequest
	*/
	TestSlackConfiguration(ctx context.Context) ApiTestSlackConfigurationRequest

	// TestSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestSlackConfigurationRequest
	*/
	TestSlackConfiguration(ctx _context.Context) ApiTestSlackConfigurationRequest

	// TestSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (NotificationSlackTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestSmtpConfiguration Method for TestSmtpConfiguration

	Test SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestSmtpConfigurationRequest
	*/
	TestSmtpConfiguration(ctx context.Context) ApiTestSmtpConfigurationRequest

	// TestSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestSmtpConfigurationRequest
	*/
	TestSmtpConfiguration(ctx _context.Context) ApiTestSmtpConfigurationRequest

	// TestSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (NotificationSMTPTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredGithubConfiguration Method for TestStoredGithubConfiguration

	Test stored GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredGithubConfigurationRequest
	*/
	TestStoredGithubConfiguration(ctx context.Context, uuid string) ApiTestStoredGithubConfigurationRequest

	// TestStoredGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredGithubConfigurationRequest
	*/
	TestStoredGithubConfiguration(ctx _context.Context, uuid string) ApiTestStoredGithubConfigurationRequest

	// TestStoredGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (NotificationGitHubTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredJiraConfiguration Method for TestStoredJiraConfiguration

	Test stored Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredJiraConfigurationRequest
	*/
	TestStoredJiraConfiguration(ctx context.Context, uuid string) ApiTestStoredJiraConfigurationRequest

	// TestStoredJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredJiraConfigurationRequest
	*/
	TestStoredJiraConfiguration(ctx _context.Context, uuid string) ApiTestStoredJiraConfigurationRequest

	// TestStoredJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (NotificationJiraTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredSlackConfiguration Method for TestStoredSlackConfiguration

	Test stored Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredSlackConfigurationRequest
	*/
	TestStoredSlackConfiguration(ctx context.Context, uuid string) ApiTestStoredSlackConfigurationRequest

	// TestStoredSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredSlackConfigurationRequest
	*/
	TestStoredSlackConfiguration(ctx _context.Context, uuid string) ApiTestStoredSlackConfigurationRequest

	// TestStoredSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (NotificationSlackTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredSmtpConfiguration Method for TestStoredSmtpConfiguration

	Test stored SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredSmtpConfigurationRequest
	*/
	TestStoredSmtpConfiguration(ctx context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest

	// TestStoredSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredSmtpConfigurationRequest
	*/
	TestStoredSmtpConfiguration(ctx _context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest

	// TestStoredSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (NotificationSMTPTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredTeamsConfiguration Method for TestStoredTeamsConfiguration

	Test stored Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredTeamsConfigurationRequest
	*/
	TestStoredTeamsConfiguration(ctx context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest

	// TestStoredTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredTeamsConfigurationRequest
	*/
	TestStoredTeamsConfiguration(ctx _context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest

	// TestStoredTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (NotificationTeamsTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestStoredWebhookConfiguration Method for TestStoredWebhookConfiguration

	Test stored Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredWebhookConfigurationRequest
	*/
	TestStoredWebhookConfiguration(ctx context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest

	// TestStoredWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiTestStoredWebhookConfigurationRequest
	*/
	TestStoredWebhookConfiguration(ctx _context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest

	// TestStoredWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (NotificationWebhookTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestTeamsConfiguration Method for TestTeamsConfiguration

	Test Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestTeamsConfigurationRequest
	*/
	TestTeamsConfiguration(ctx context.Context) ApiTestTeamsConfigurationRequest

	// TestTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestTeamsConfigurationRequest
	*/
	TestTeamsConfiguration(ctx _context.Context) ApiTestTeamsConfigurationRequest

	// TestTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (NotificationTeamsTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	TestWebhookConfiguration Method for TestWebhookConfiguration

	Test Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestWebhookConfigurationRequest
	*/
	TestWebhookConfiguration(ctx context.Context) ApiTestWebhookConfigurationRequest

	// TestWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiTestWebhookConfigurationRequest
	*/
	TestWebhookConfiguration(ctx _context.Context) ApiTestWebhookConfigurationRequest

	// TestWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (NotificationWebhookTestResult, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateEndpointStatus Method for UpdateEndpointStatus

	Update enabled status of an endpoint

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateEndpointStatusRequest
	*/
	UpdateEndpointStatus(ctx context.Context, name string) ApiUpdateEndpointStatusRequest

	// UpdateEndpointStatusExecute executes the request
	//  @return NotificationEndpointEnabledStatus
	UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (*NotificationEndpointEnabledStatus, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiUpdateEndpointStatusRequest
	*/
	UpdateEndpointStatus(ctx _context.Context, name string) ApiUpdateEndpointStatusRequest

	// UpdateEndpointStatusExecute executes the request
	//  @return NotificationEndpointEnabledStatus
	UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (NotificationEndpointEnabledStatus, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateGithubConfiguration Method for UpdateGithubConfiguration

	Update a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateGithubConfigurationRequest
	*/
	UpdateGithubConfiguration(ctx context.Context, uuid string) ApiUpdateGithubConfigurationRequest

	// UpdateGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateGithubConfigurationRequest
	*/
	UpdateGithubConfiguration(ctx _context.Context, uuid string) ApiUpdateGithubConfigurationRequest

	// UpdateGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateGithubSelector Method for UpdateGithubSelector

	Update a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateGithubSelectorRequest
	*/
	UpdateGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest

	// UpdateGithubSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateGithubSelectorRequest
	*/
	UpdateGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest

	// UpdateGithubSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateIdp Method for UpdateIdp

	Update an existing Identity Provider configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateIdpRequest
	*/
	UpdateIdp(ctx context.Context, name string) ApiUpdateIdpRequest

	// UpdateIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	UpdateIdpExecute(r ApiUpdateIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param name
	 @return ApiUpdateIdpRequest
	*/
	UpdateIdp(ctx _context.Context, name string) ApiUpdateIdpRequest

	// UpdateIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	UpdateIdpExecute(r ApiUpdateIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateJiraConfiguration Method for UpdateJiraConfiguration

	Update a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateJiraConfigurationRequest
	*/
	UpdateJiraConfiguration(ctx context.Context, uuid string) ApiUpdateJiraConfigurationRequest

	// UpdateJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateJiraConfigurationRequest
	*/
	UpdateJiraConfiguration(ctx _context.Context, uuid string) ApiUpdateJiraConfigurationRequest

	// UpdateJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateJiraSelector Method for UpdateJiraSelector

	Update a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateJiraSelectorRequest
	*/
	UpdateJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest

	// UpdateJiraSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateJiraSelectorRequest
	*/
	UpdateJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest

	// UpdateJiraSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateSlackConfiguration Method for UpdateSlackConfiguration

	Update a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateSlackConfigurationRequest
	*/
	UpdateSlackConfiguration(ctx context.Context, uuid string) ApiUpdateSlackConfigurationRequest

	// UpdateSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateSlackConfigurationRequest
	*/
	UpdateSlackConfiguration(ctx _context.Context, uuid string) ApiUpdateSlackConfigurationRequest

	// UpdateSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateSlackSelector Method for UpdateSlackSelector

	Update a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateSlackSelectorRequest
	*/
	UpdateSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest

	// UpdateSlackSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateSlackSelectorRequest
	*/
	UpdateSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest

	// UpdateSlackSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateSmtpConfiguration Method for UpdateSmtpConfiguration

	Update a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateSmtpConfigurationRequest
	*/
	UpdateSmtpConfiguration(ctx context.Context, uuid string) ApiUpdateSmtpConfigurationRequest

	// UpdateSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateSmtpConfigurationRequest
	*/
	UpdateSmtpConfiguration(ctx _context.Context, uuid string) ApiUpdateSmtpConfigurationRequest

	// UpdateSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateSmtpSelector Method for UpdateSmtpSelector

	Update a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateSmtpSelectorRequest
	*/
	UpdateSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest

	// UpdateSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateSmtpSelectorRequest
	*/
	UpdateSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest

	// UpdateSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateTeamsConfiguration Method for UpdateTeamsConfiguration

	Update a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateTeamsConfigurationRequest
	*/
	UpdateTeamsConfiguration(ctx context.Context, uuid string) ApiUpdateTeamsConfigurationRequest

	// UpdateTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateTeamsConfigurationRequest
	*/
	UpdateTeamsConfiguration(ctx _context.Context, uuid string) ApiUpdateTeamsConfigurationRequest

	// UpdateTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateTeamsSelector Method for UpdateTeamsSelector

	Update a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateTeamsSelectorRequest
	*/
	UpdateTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest

	// UpdateTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateTeamsSelectorRequest
	*/
	UpdateTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest

	// UpdateTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateWebhookConfiguration Method for UpdateWebhookConfiguration

	Update a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateWebhookConfigurationRequest
	*/
	UpdateWebhookConfiguration(ctx context.Context, uuid string) ApiUpdateWebhookConfigurationRequest

	// UpdateWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param uuid
	 @return ApiUpdateWebhookConfigurationRequest
	*/
	UpdateWebhookConfiguration(ctx _context.Context, uuid string) ApiUpdateWebhookConfigurationRequest

	// UpdateWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error)
>>>>>>> main

	/*
	UpdateWebhookSelector Method for UpdateWebhookSelector

	Update a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateWebhookSelectorRequest
	*/
	UpdateWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest

	// UpdateWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param configurationUuid
	 @param selectorUuid
	 @return ApiUpdateWebhookSelectorRequest
	*/
	UpdateWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest

	// UpdateWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error)
>>>>>>> main

	/*
	VersionCheck Method for VersionCheck

	Returns the version object for the service, including db schema version info

<<<<<<< HEAD
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVersionCheckRequest
	*/
	VersionCheck(ctx context.Context) ApiVersionCheckRequest

	// VersionCheckExecute executes the request
	//  @return ServiceVersion
	VersionCheckExecute(r ApiVersionCheckRequest) (*ServiceVersion, *http.Response, error)
=======
	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiVersionCheckRequest
	*/
	VersionCheck(ctx _context.Context) ApiVersionCheckRequest

	// VersionCheckExecute executes the request
	//  @return ServiceVersion
	VersionCheckExecute(r ApiVersionCheckRequest) (ServiceVersion, *_nethttp.Response, error)
>>>>>>> main
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAddGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationGitHubEndpointConfigurationPost
}

func (r ApiAddGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPost) ApiAddGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
=======
func (r ApiAddGithubConfigurationRequest) Execute() (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddGithubConfigurationExecute(r)
}

/*
AddGithubConfiguration Method for AddGithubConfiguration

Create a new GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddGithubConfigurationRequest
*/
func (a *DefaultApiService) AddGithubConfiguration(ctx context.Context) ApiAddGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddGithubConfigurationRequest
*/
func (a *DefaultApiService) AddGithubConfiguration(ctx _context.Context) ApiAddGithubConfigurationRequest {
>>>>>>> main
	return ApiAddGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
=======
func (a *DefaultApiService) AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationGitHubEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddGithubSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddGithubSelectorRequest) Selector(selector NotificationSelector) ApiAddGithubSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddGithubSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddGithubSelectorExecute(r)
}

/*
AddGithubSelector Method for AddGithubSelector

Add selector for mapping events for delivery to a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddGithubSelectorRequest
*/
func (a *DefaultApiService) AddGithubSelector(ctx context.Context, uuid string) ApiAddGithubSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddGithubSelectorRequest
*/
func (a *DefaultApiService) AddGithubSelector(ctx _context.Context, uuid string) ApiAddGithubSelectorRequest {
>>>>>>> main
	return ApiAddGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddGithubSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddIdpRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *RbacManagerSamlConfiguration
}

func (r ApiAddIdpRequest) Configuration(configuration RbacManagerSamlConfiguration) ApiAddIdpRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
=======
func (r ApiAddIdpRequest) Execute() (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddIdpExecute(r)
}

/*
AddIdp Method for AddIdp

Add a new Identity Provider to the system, with a specific name

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddIdpRequest
*/
func (a *DefaultApiService) AddIdp(ctx context.Context) ApiAddIdpRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddIdpRequest
*/
func (a *DefaultApiService) AddIdp(ctx _context.Context) ApiAddIdpRequest {
>>>>>>> main
	return ApiAddIdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) AddIdpExecute(r ApiAddIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
=======
func (a *DefaultApiService) AddIdpExecute(r ApiAddIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerSamlConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddIdp")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationJiraEndpointConfigurationPost
}

func (r ApiAddJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPost) ApiAddJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
=======
func (r ApiAddJiraConfigurationRequest) Execute() (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddJiraConfigurationExecute(r)
}

/*
AddJiraConfiguration Method for AddJiraConfiguration

Create a new Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddJiraConfigurationRequest
*/
func (a *DefaultApiService) AddJiraConfiguration(ctx context.Context) ApiAddJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddJiraConfigurationRequest
*/
func (a *DefaultApiService) AddJiraConfiguration(ctx _context.Context) ApiAddJiraConfigurationRequest {
>>>>>>> main
	return ApiAddJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
=======
func (a *DefaultApiService) AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationJiraEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddJiraSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddJiraSelectorRequest) Selector(selector NotificationSelector) ApiAddJiraSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddJiraSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddJiraSelectorExecute(r)
}

/*
AddJiraSelector Method for AddJiraSelector

Add selector for mapping events for delivery to a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddJiraSelectorRequest
*/
func (a *DefaultApiService) AddJiraSelector(ctx context.Context, uuid string) ApiAddJiraSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddJiraSelectorRequest
*/
func (a *DefaultApiService) AddJiraSelector(ctx _context.Context, uuid string) ApiAddJiraSelectorRequest {
>>>>>>> main
	return ApiAddJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddJiraSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddRoleUserRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	roleName string
	member *RbacManagerRoleMember
}

func (r ApiAddRoleUserRequest) Member(member RbacManagerRoleMember) ApiAddRoleUserRequest {
	r.member = &member
	return r
}

<<<<<<< HEAD
func (r ApiAddRoleUserRequest) Execute() (*RbacManagerRoleMember, *http.Response, error) {
=======
func (r ApiAddRoleUserRequest) Execute() (RbacManagerRoleMember, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddRoleUserExecute(r)
}

/*
AddRoleUser Add a user to the role

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiAddRoleUserRequest
*/
func (a *DefaultApiService) AddRoleUser(ctx context.Context, roleName string) ApiAddRoleUserRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiAddRoleUserRequest
*/
func (a *DefaultApiService) AddRoleUser(ctx _context.Context, roleName string) ApiAddRoleUserRequest {
>>>>>>> main
	return ApiAddRoleUserRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RbacManagerRoleMember
<<<<<<< HEAD
func (a *DefaultApiService) AddRoleUserExecute(r ApiAddRoleUserRequest) (*RbacManagerRoleMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerRoleMember
=======
func (a *DefaultApiService) AddRoleUserExecute(r ApiAddRoleUserRequest) (RbacManagerRoleMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerRoleMember
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddRoleUser")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", _neturl.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.member == nil {
		return localVarReturnValue, nil, reportError("member is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.member
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiAddSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiAddSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
=======
func (r ApiAddSlackConfigurationRequest) Execute() (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddSlackConfigurationExecute(r)
}

/*
AddSlackConfiguration Method for AddSlackConfiguration

Create a new Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSlackConfigurationRequest
*/
func (a *DefaultApiService) AddSlackConfiguration(ctx context.Context) ApiAddSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSlackConfigurationRequest
*/
func (a *DefaultApiService) AddSlackConfiguration(ctx _context.Context) ApiAddSlackConfigurationRequest {
>>>>>>> main
	return ApiAddSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
=======
func (a *DefaultApiService) AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSlackEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSlackSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddSlackSelectorRequest) Selector(selector NotificationSelector) ApiAddSlackSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddSlackSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddSlackSelectorExecute(r)
}

/*
AddSlackSelector Method for AddSlackSelector

Add selector for mapping events for delivery to a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSlackSelectorRequest
*/
func (a *DefaultApiService) AddSlackSelector(ctx context.Context, uuid string) ApiAddSlackSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSlackSelectorRequest
*/
func (a *DefaultApiService) AddSlackSelector(ctx _context.Context, uuid string) ApiAddSlackSelectorRequest {
>>>>>>> main
	return ApiAddSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSlackSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiAddSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiAddSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
=======
func (r ApiAddSmtpConfigurationRequest) Execute() (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddSmtpConfigurationExecute(r)
}

/*
AddSmtpConfiguration Method for AddSmtpConfiguration

Create a new SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSmtpConfigurationRequest
*/
func (a *DefaultApiService) AddSmtpConfiguration(ctx context.Context) ApiAddSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSmtpConfigurationRequest
*/
func (a *DefaultApiService) AddSmtpConfiguration(ctx _context.Context) ApiAddSmtpConfigurationRequest {
>>>>>>> main
	return ApiAddSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
=======
func (a *DefaultApiService) AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSMTPEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSmtpSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddSmtpSelectorRequest) Selector(selector NotificationSelector) ApiAddSmtpSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddSmtpSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddSmtpSelectorExecute(r)
}

/*
AddSmtpSelector Method for AddSmtpSelector

Add selector for mapping events for delivery to a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSmtpSelectorRequest
*/
func (a *DefaultApiService) AddSmtpSelector(ctx context.Context, uuid string) ApiAddSmtpSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSmtpSelectorRequest
*/
func (a *DefaultApiService) AddSmtpSelector(ctx _context.Context, uuid string) ApiAddSmtpSelectorRequest {
>>>>>>> main
	return ApiAddSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSmtpSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiAddTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiAddTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
=======
func (r ApiAddTeamsConfigurationRequest) Execute() (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddTeamsConfigurationExecute(r)
}

/*
AddTeamsConfiguration Method for AddTeamsConfiguration

Create a new Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddTeamsConfigurationRequest
*/
func (a *DefaultApiService) AddTeamsConfiguration(ctx context.Context) ApiAddTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddTeamsConfigurationRequest
*/
func (a *DefaultApiService) AddTeamsConfiguration(ctx _context.Context) ApiAddTeamsConfigurationRequest {
>>>>>>> main
	return ApiAddTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
=======
func (a *DefaultApiService) AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationTeamsEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTeamsSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddTeamsSelectorRequest) Selector(selector NotificationSelector) ApiAddTeamsSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddTeamsSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddTeamsSelectorExecute(r)
}

/*
AddTeamsSelector Method for AddTeamsSelector

Add selector for mapping events for delivery to a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddTeamsSelectorRequest
*/
func (a *DefaultApiService) AddTeamsSelector(ctx context.Context, uuid string) ApiAddTeamsSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddTeamsSelectorRequest
*/
func (a *DefaultApiService) AddTeamsSelector(ctx _context.Context, uuid string) ApiAddTeamsSelectorRequest {
>>>>>>> main
	return ApiAddTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddTeamsSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiAddWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiAddWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiAddWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
=======
func (r ApiAddWebhookConfigurationRequest) Execute() (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddWebhookConfigurationExecute(r)
}

/*
AddWebhookConfiguration Method for AddWebhookConfiguration

Create a new Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddWebhookConfigurationRequest
*/
func (a *DefaultApiService) AddWebhookConfiguration(ctx context.Context) ApiAddWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddWebhookConfigurationRequest
*/
func (a *DefaultApiService) AddWebhookConfiguration(ctx _context.Context) ApiAddWebhookConfigurationRequest {
>>>>>>> main
	return ApiAddWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
=======
func (a *DefaultApiService) AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddWebhookSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddWebhookSelectorRequest) Selector(selector NotificationSelector) ApiAddWebhookSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiAddWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiAddWebhookSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.AddWebhookSelectorExecute(r)
}

/*
AddWebhookSelector Method for AddWebhookSelector

Add selector for mapping events for delivery to a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddWebhookSelectorRequest
*/
func (a *DefaultApiService) AddWebhookSelector(ctx context.Context, uuid string) ApiAddWebhookSelectorRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddWebhookSelectorRequest
*/
func (a *DefaultApiService) AddWebhookSelector(ctx _context.Context, uuid string) ApiAddWebhookSelectorRequest {
>>>>>>> main
	return ApiAddWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddWebhookSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteGithubConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteGithubConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteGithubConfigurationExecute(r)
}

/*
DeleteGithubConfiguration Method for DeleteGithubConfiguration

Delete a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteGithubConfigurationRequest
*/
func (a *DefaultApiService) DeleteGithubConfiguration(ctx context.Context, uuid string) ApiDeleteGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteGithubConfigurationRequest
*/
func (a *DefaultApiService) DeleteGithubConfiguration(ctx _context.Context, uuid string) ApiDeleteGithubConfigurationRequest {
>>>>>>> main
	return ApiDeleteGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGithubSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteGithubSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteGithubSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteGithubSelectorExecute(r)
}

/*
DeleteGithubSelector Method for DeleteGithubSelector

Delete a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteGithubSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest {
=======
func (a *DefaultApiService) DeleteGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest {
>>>>>>> main
	return ApiDeleteGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteGithubSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteIdpRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	name string
}

<<<<<<< HEAD
func (r ApiDeleteIdpRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteIdpRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteIdpExecute(r)
}

/*
DeleteIdp Method for DeleteIdp

Delete an idp configuration. Users will not longer be able to login from this idp. In addition, any users that have been configured explicitly or JIT Provisioned on this IDP will be deleted.

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiDeleteIdpRequest
*/
func (a *DefaultApiService) DeleteIdp(ctx context.Context, name string) ApiDeleteIdpRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiDeleteIdpRequest
*/
func (a *DefaultApiService) DeleteIdp(ctx _context.Context, name string) ApiDeleteIdpRequest {
>>>>>>> main
	return ApiDeleteIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteIdpExecute(r ApiDeleteIdpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteIdpExecute(r ApiDeleteIdpRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIdp")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteJiraConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteJiraConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteJiraConfigurationExecute(r)
}

/*
DeleteJiraConfiguration Method for DeleteJiraConfiguration

Delete a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteJiraConfigurationRequest
*/
func (a *DefaultApiService) DeleteJiraConfiguration(ctx context.Context, uuid string) ApiDeleteJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteJiraConfigurationRequest
*/
func (a *DefaultApiService) DeleteJiraConfiguration(ctx _context.Context, uuid string) ApiDeleteJiraConfigurationRequest {
>>>>>>> main
	return ApiDeleteJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteJiraSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteJiraSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteJiraSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteJiraSelectorExecute(r)
}

/*
DeleteJiraSelector Method for DeleteJiraSelector

Delete a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteJiraSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest {
=======
func (a *DefaultApiService) DeleteJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest {
>>>>>>> main
	return ApiDeleteJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteJiraSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRoleUserRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	roleName string
	username *string
	forAccount *string
}

// The username to remove the role for
func (r ApiDeleteRoleUserRequest) Username(username string) ApiDeleteRoleUserRequest {
	r.username = &username
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// The account that the user has the role to be removed
func (r ApiDeleteRoleUserRequest) ForAccount(forAccount string) ApiDeleteRoleUserRequest {
	r.forAccount = &forAccount
	return r
}

<<<<<<< HEAD
func (r ApiDeleteRoleUserRequest) Execute() (*http.Response, error) {
=======
func (r ApiDeleteRoleUserRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteRoleUserExecute(r)
}

/*
DeleteRoleUser Remove a user from the role

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiDeleteRoleUserRequest
*/
func (a *DefaultApiService) DeleteRoleUser(ctx context.Context, roleName string) ApiDeleteRoleUserRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiDeleteRoleUserRequest
*/
func (a *DefaultApiService) DeleteRoleUser(ctx _context.Context, roleName string) ApiDeleteRoleUserRequest {
>>>>>>> main
	return ApiDeleteRoleUserRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRoleUser")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", _neturl.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.username == nil {
		return nil, reportError("username is required and must be specified")
	}
	if r.forAccount == nil {
		return nil, reportError("forAccount is required and must be specified")
	}

	localVarQueryParams.Add("username", parameterToString(*r.username, ""))
	localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteSlackConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteSlackConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteSlackConfigurationExecute(r)
}

/*
DeleteSlackConfiguration Method for DeleteSlackConfiguration

Delete a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSlackConfigurationRequest
*/
func (a *DefaultApiService) DeleteSlackConfiguration(ctx context.Context, uuid string) ApiDeleteSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSlackConfigurationRequest
*/
func (a *DefaultApiService) DeleteSlackConfiguration(ctx _context.Context, uuid string) ApiDeleteSlackConfigurationRequest {
>>>>>>> main
	return ApiDeleteSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteSlackSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteSlackSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteSlackSelectorExecute(r)
}

/*
DeleteSlackSelector Method for DeleteSlackSelector

Delete a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteSlackSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest {
=======
func (a *DefaultApiService) DeleteSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest {
>>>>>>> main
	return ApiDeleteSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSlackSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteSmtpConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteSmtpConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteSmtpConfigurationExecute(r)
}

/*
DeleteSmtpConfiguration Method for DeleteSmtpConfiguration

Delete a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSmtpConfigurationRequest
*/
func (a *DefaultApiService) DeleteSmtpConfiguration(ctx context.Context, uuid string) ApiDeleteSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSmtpConfigurationRequest
*/
func (a *DefaultApiService) DeleteSmtpConfiguration(ctx _context.Context, uuid string) ApiDeleteSmtpConfigurationRequest {
>>>>>>> main
	return ApiDeleteSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSmtpSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteSmtpSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteSmtpSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteSmtpSelectorExecute(r)
}

/*
DeleteSmtpSelector Method for DeleteSmtpSelector

Delete a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteSmtpSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest {
=======
func (a *DefaultApiService) DeleteSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest {
>>>>>>> main
	return ApiDeleteSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSmtpSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteTeamsConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteTeamsConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteTeamsConfigurationExecute(r)
}

/*
DeleteTeamsConfiguration Method for DeleteTeamsConfiguration

Delete a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteTeamsConfigurationRequest
*/
func (a *DefaultApiService) DeleteTeamsConfiguration(ctx context.Context, uuid string) ApiDeleteTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteTeamsConfigurationRequest
*/
func (a *DefaultApiService) DeleteTeamsConfiguration(ctx _context.Context, uuid string) ApiDeleteTeamsConfigurationRequest {
>>>>>>> main
	return ApiDeleteTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeamsSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteTeamsSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteTeamsSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteTeamsSelectorExecute(r)
}

/*
DeleteTeamsSelector Method for DeleteTeamsSelector

Delete a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteTeamsSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest {
=======
func (a *DefaultApiService) DeleteTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest {
>>>>>>> main
	return ApiDeleteTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTeamsSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiDeleteWebhookConfigurationRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteWebhookConfigurationRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteWebhookConfigurationExecute(r)
}

/*
DeleteWebhookConfiguration Method for DeleteWebhookConfiguration

Delete a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteWebhookConfigurationRequest
*/
func (a *DefaultApiService) DeleteWebhookConfiguration(ctx context.Context, uuid string) ApiDeleteWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteWebhookConfigurationRequest
*/
func (a *DefaultApiService) DeleteWebhookConfiguration(ctx _context.Context, uuid string) ApiDeleteWebhookConfigurationRequest {
>>>>>>> main
	return ApiDeleteWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiDeleteWebhookSelectorRequest) Execute() (*http.Response, error) {
=======

func (r ApiDeleteWebhookSelectorRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.DeleteWebhookSelectorExecute(r)
}

/*
DeleteWebhookSelector Method for DeleteWebhookSelector

Delete a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteWebhookSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) DeleteWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest {
=======
func (a *DefaultApiService) DeleteWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest {
>>>>>>> main
	return ApiDeleteWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteWebhookSelector")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
=======

func (r ApiGetGithubConfigurationRequest) Execute() (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetGithubConfigurationExecute(r)
}

/*
GetGithubConfiguration Method for GetGithubConfiguration

Get a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationRequest
*/
func (a *DefaultApiService) GetGithubConfiguration(ctx context.Context, uuid string) ApiGetGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationRequest
*/
func (a *DefaultApiService) GetGithubConfiguration(ctx _context.Context, uuid string) ApiGetGithubConfigurationRequest {
>>>>>>> main
	return ApiGetGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
=======
func (a *DefaultApiService) GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationGitHubEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetGithubConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetGithubConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetGithubConfigurationStatusExecute(r)
}

/*
GetGithubConfigurationStatus Method for GetGithubConfigurationStatus

Get operational status for a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationStatusRequest
*/
func (a *DefaultApiService) GetGithubConfigurationStatus(ctx context.Context, uuid string) ApiGetGithubConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationStatusRequest
*/
func (a *DefaultApiService) GetGithubConfigurationStatus(ctx _context.Context, uuid string) ApiGetGithubConfigurationStatusRequest {
>>>>>>> main
	return ApiGetGithubConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetGithubSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetGithubSelectorExecute(r)
}

/*
GetGithubSelector Method for GetGithubSelector

Get a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetGithubSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest {
=======
func (a *DefaultApiService) GetGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest {
>>>>>>> main
	return ApiGetGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalQueryResultRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	resultUuid string
	page *int32
}

// Page number to fetch. If omitted, &#39;1&#39; is default. Page numbers start at 1
func (r ApiGetGlobalQueryResultRequest) Page(page int32) ApiGetGlobalQueryResultRequest {
	r.page = &page
	return r
}

<<<<<<< HEAD
func (r ApiGetGlobalQueryResultRequest) Execute() (*http.Response, error) {
=======
func (r ApiGetGlobalQueryResultRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetGlobalQueryResultExecute(r)
}

/*
GetGlobalQueryResult Method for GetGlobalQueryResult

Get a single saved global query result

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetGlobalQueryResultRequest
*/
func (a *DefaultApiService) GetGlobalQueryResult(ctx context.Context, resultUuid string) ApiGetGlobalQueryResultRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetGlobalQueryResultRequest
*/
func (a *DefaultApiService) GetGlobalQueryResult(ctx _context.Context, resultUuid string) ApiGetGlobalQueryResultRequest {
>>>>>>> main
	return ApiGetGlobalQueryResultRequest{
		ApiService: a,
		ctx: ctx,
		resultUuid: resultUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGlobalQueryResult")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/reports/global/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", url.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/reports/global/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", _neturl.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIdpRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	name string
}

<<<<<<< HEAD
func (r ApiGetIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
=======

func (r ApiGetIdpRequest) Execute() (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetIdpExecute(r)
}

/*
GetIdp Method for GetIdp

Return the configuration for a named Identity Provider

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetIdpRequest
*/
func (a *DefaultApiService) GetIdp(ctx context.Context, name string) ApiGetIdpRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetIdpRequest
*/
func (a *DefaultApiService) GetIdp(ctx _context.Context, name string) ApiGetIdpRequest {
>>>>>>> main
	return ApiGetIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) GetIdpExecute(r ApiGetIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
=======
func (a *DefaultApiService) GetIdpExecute(r ApiGetIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerSamlConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIdp")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
=======

func (r ApiGetJiraConfigurationRequest) Execute() (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetJiraConfigurationExecute(r)
}

/*
GetJiraConfiguration Method for GetJiraConfiguration

Get a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationRequest
*/
func (a *DefaultApiService) GetJiraConfiguration(ctx context.Context, uuid string) ApiGetJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationRequest
*/
func (a *DefaultApiService) GetJiraConfiguration(ctx _context.Context, uuid string) ApiGetJiraConfigurationRequest {
>>>>>>> main
	return ApiGetJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
=======
func (a *DefaultApiService) GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationJiraEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetJiraConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetJiraConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetJiraConfigurationStatusExecute(r)
}

/*
GetJiraConfigurationStatus Method for GetJiraConfigurationStatus

Get operational status for a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationStatusRequest
*/
func (a *DefaultApiService) GetJiraConfigurationStatus(ctx context.Context, uuid string) ApiGetJiraConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationStatusRequest
*/
func (a *DefaultApiService) GetJiraConfigurationStatus(ctx _context.Context, uuid string) ApiGetJiraConfigurationStatusRequest {
>>>>>>> main
	return ApiGetJiraConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetJiraSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetJiraSelectorExecute(r)
}

/*
GetJiraSelector Method for GetJiraSelector

Get a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetJiraSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest {
=======
func (a *DefaultApiService) GetJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest {
>>>>>>> main
	return ApiGetJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOauthTokenRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	grantType *string
	username *string
	password *string
	clientId *string
	refreshToken *string
}

// OAuth Grant type for token
func (r ApiGetOauthTokenRequest) GrantType(grantType string) ApiGetOauthTokenRequest {
	r.grantType = &grantType
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// User to assign OAuth token to
func (r ApiGetOauthTokenRequest) Username(username string) ApiGetOauthTokenRequest {
	r.username = &username
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// Password for corresponding user
func (r ApiGetOauthTokenRequest) Password(password string) ApiGetOauthTokenRequest {
	r.password = &password
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// The type of client used for the OAuth token
func (r ApiGetOauthTokenRequest) ClientId(clientId string) ApiGetOauthTokenRequest {
	r.clientId = &clientId
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// The refresh token from a previous password grant request, used to get a new access_token
func (r ApiGetOauthTokenRequest) RefreshToken(refreshToken string) ApiGetOauthTokenRequest {
	r.refreshToken = &refreshToken
	return r
}

<<<<<<< HEAD
func (r ApiGetOauthTokenRequest) Execute() (*TokenResponse, *http.Response, error) {
=======
func (r ApiGetOauthTokenRequest) Execute() (TokenResponse, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetOauthTokenExecute(r)
}

/*
GetOauthToken Method for GetOauthToken

Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOauthTokenRequest
*/
func (a *DefaultApiService) GetOauthToken(ctx context.Context) ApiGetOauthTokenRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOauthTokenRequest
*/
func (a *DefaultApiService) GetOauthToken(ctx _context.Context) ApiGetOauthTokenRequest {
>>>>>>> main
	return ApiGetOauthTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenResponse
<<<<<<< HEAD
func (a *DefaultApiService) GetOauthTokenExecute(r ApiGetOauthTokenRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
=======
func (a *DefaultApiService) GetOauthTokenExecute(r ApiGetOauthTokenRequest) (TokenResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TokenResponse
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetOauthToken")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.grantType != nil {
		localVarFormParams.Add("grant_type", parameterToString(*r.grantType, ""))
	}
	if r.username != nil {
		localVarFormParams.Add("username", parameterToString(*r.username, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.clientId != nil {
		localVarFormParams.Add("client_id", parameterToString(*r.clientId, ""))
	}
	if r.refreshToken != nil {
		localVarFormParams.Add("refresh_token", parameterToString(*r.refreshToken, ""))
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryResultRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	resultUuid string
	page *int32
}

// Page number to fetch. If omitted, &#39;1&#39; is default. Page numbers start at 1
func (r ApiGetQueryResultRequest) Page(page int32) ApiGetQueryResultRequest {
	r.page = &page
	return r
}

<<<<<<< HEAD
func (r ApiGetQueryResultRequest) Execute() (*http.Response, error) {
=======
func (r ApiGetQueryResultRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetQueryResultExecute(r)
}

/*
GetQueryResult Method for GetQueryResult

Get a single saved query result

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetQueryResultRequest
*/
func (a *DefaultApiService) GetQueryResult(ctx context.Context, resultUuid string) ApiGetQueryResultRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetQueryResultRequest
*/
func (a *DefaultApiService) GetQueryResult(ctx _context.Context, resultUuid string) ApiGetQueryResultRequest {
>>>>>>> main
	return ApiGetQueryResultRequest{
		ApiService: a,
		ctx: ctx,
		resultUuid: resultUuid,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) GetQueryResultExecute(r ApiGetQueryResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) GetQueryResultExecute(r ApiGetQueryResultRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetQueryResult")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", url.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", _neturl.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRoleRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	roleName string
}

<<<<<<< HEAD
func (r ApiGetRoleRequest) Execute() (*RbacManagerRole, *http.Response, error) {
=======

func (r ApiGetRoleRequest) Execute() (RbacManagerRole, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetRoleExecute(r)
}

/*
GetRole Get detailed information about a specific role

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiGetRoleRequest
*/
func (a *DefaultApiService) GetRole(ctx context.Context, roleName string) ApiGetRoleRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiGetRoleRequest
*/
func (a *DefaultApiService) GetRole(ctx _context.Context, roleName string) ApiGetRoleRequest {
>>>>>>> main
	return ApiGetRoleRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RbacManagerRole
<<<<<<< HEAD
func (a *DefaultApiService) GetRoleExecute(r ApiGetRoleRequest) (*RbacManagerRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerRole
=======
func (a *DefaultApiService) GetRoleExecute(r ApiGetRoleRequest) (RbacManagerRole, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerRole
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRole")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", _neturl.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
=======

func (r ApiGetSlackConfigurationRequest) Execute() (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSlackConfigurationExecute(r)
}

/*
GetSlackConfiguration Method for GetSlackConfiguration

Get a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationRequest
*/
func (a *DefaultApiService) GetSlackConfiguration(ctx context.Context, uuid string) ApiGetSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationRequest
*/
func (a *DefaultApiService) GetSlackConfiguration(ctx _context.Context, uuid string) ApiGetSlackConfigurationRequest {
>>>>>>> main
	return ApiGetSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
=======
func (a *DefaultApiService) GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSlackEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetSlackConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetSlackConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSlackConfigurationStatusExecute(r)
}

/*
GetSlackConfigurationStatus Method for GetSlackConfigurationStatus

Get operational status for a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSlackConfigurationStatus(ctx context.Context, uuid string) ApiGetSlackConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSlackConfigurationStatus(ctx _context.Context, uuid string) ApiGetSlackConfigurationStatusRequest {
>>>>>>> main
	return ApiGetSlackConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetSlackSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSlackSelectorExecute(r)
}

/*
GetSlackSelector Method for GetSlackSelector

Get a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetSlackSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest {
=======
func (a *DefaultApiService) GetSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest {
>>>>>>> main
	return ApiGetSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
=======

func (r ApiGetSmtpConfigurationRequest) Execute() (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSmtpConfigurationExecute(r)
}

/*
GetSmtpConfiguration Method for GetSmtpConfiguration

Get a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationRequest
*/
func (a *DefaultApiService) GetSmtpConfiguration(ctx context.Context, uuid string) ApiGetSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationRequest
*/
func (a *DefaultApiService) GetSmtpConfiguration(ctx _context.Context, uuid string) ApiGetSmtpConfigurationRequest {
>>>>>>> main
	return ApiGetSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
=======
func (a *DefaultApiService) GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSMTPEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetSmtpConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetSmtpConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSmtpConfigurationStatusExecute(r)
}

/*
GetSmtpConfigurationStatus Method for GetSmtpConfigurationStatus

Get operational status for a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSmtpConfigurationStatus(ctx context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSmtpConfigurationStatus(ctx _context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest {
>>>>>>> main
	return ApiGetSmtpConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetSmtpSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetSmtpSelectorExecute(r)
}

/*
GetSmtpSelector Method for GetSmtpSelector

Get a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetSmtpSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest {
=======
func (a *DefaultApiService) GetSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest {
>>>>>>> main
	return ApiGetSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
=======

func (r ApiGetTeamsConfigurationRequest) Execute() (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetTeamsConfigurationExecute(r)
}

/*
GetTeamsConfiguration Method for GetTeamsConfiguration

Get a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationRequest
*/
func (a *DefaultApiService) GetTeamsConfiguration(ctx context.Context, uuid string) ApiGetTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationRequest
*/
func (a *DefaultApiService) GetTeamsConfiguration(ctx _context.Context, uuid string) ApiGetTeamsConfigurationRequest {
>>>>>>> main
	return ApiGetTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
=======
func (a *DefaultApiService) GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationTeamsEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetTeamsConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetTeamsConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetTeamsConfigurationStatusExecute(r)
}

/*
GetTeamsConfigurationStatus Method for GetTeamsConfigurationStatus

Get operational status for a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationStatusRequest
*/
func (a *DefaultApiService) GetTeamsConfigurationStatus(ctx context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationStatusRequest
*/
func (a *DefaultApiService) GetTeamsConfigurationStatus(ctx _context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest {
>>>>>>> main
	return ApiGetTeamsConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetTeamsSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetTeamsSelectorExecute(r)
}

/*
GetTeamsSelector Method for GetTeamsSelector

Get a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetTeamsSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest {
=======
func (a *DefaultApiService) GetTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest {
>>>>>>> main
	return ApiGetTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
=======

func (r ApiGetWebhookConfigurationRequest) Execute() (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetWebhookConfigurationExecute(r)
}

/*
GetWebhookConfiguration Method for GetWebhookConfiguration

Get a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationRequest
*/
func (a *DefaultApiService) GetWebhookConfiguration(ctx context.Context, uuid string) ApiGetWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationRequest
*/
func (a *DefaultApiService) GetWebhookConfiguration(ctx _context.Context, uuid string) ApiGetWebhookConfigurationRequest {
>>>>>>> main
	return ApiGetWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
=======
func (a *DefaultApiService) GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookConfigurationStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiGetWebhookConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
=======

func (r ApiGetWebhookConfigurationStatusRequest) Execute() (NotificationOperationalStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetWebhookConfigurationStatusExecute(r)
}

/*
GetWebhookConfigurationStatus Method for GetWebhookConfigurationStatus

Get operational status for a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationStatusRequest
*/
func (a *DefaultApiService) GetWebhookConfigurationStatus(ctx context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationStatusRequest
*/
func (a *DefaultApiService) GetWebhookConfigurationStatus(ctx _context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest {
>>>>>>> main
	return ApiGetWebhookConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
<<<<<<< HEAD
func (a *DefaultApiService) GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
=======
func (a *DefaultApiService) GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (NotificationOperationalStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationOperationalStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookConfigurationStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

<<<<<<< HEAD
func (r ApiGetWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======

func (r ApiGetWebhookSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.GetWebhookSelectorExecute(r)
}

/*
GetWebhookSelector Method for GetWebhookSelector

Get a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiGetWebhookSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) GetWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest {
=======
func (a *DefaultApiService) GetWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest {
>>>>>>> main
	return ApiGetWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthCheckRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiHealthCheckRequest) Execute() (*http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiHealthCheckRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.HealthCheckExecute(r)
}

/*
HealthCheck Method for HealthCheck

Health check, returns 200 and no body if service is running

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthCheckRequest
*/
func (a *DefaultApiService) HealthCheck(ctx context.Context) ApiHealthCheckRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthCheckRequest
*/
func (a *DefaultApiService) HealthCheck(ctx _context.Context) ApiHealthCheckRequest {
>>>>>>> main
	return ApiHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) HealthCheckExecute(r ApiHealthCheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) HealthCheckExecute(r ApiHealthCheckRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HealthCheck")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/health"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListEndpointsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListEndpointsRequest) Execute() ([]NotificationEndpoint, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListEndpointsRequest) Execute() ([]NotificationEndpoint, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListEndpointsExecute(r)
}

/*
ListEndpoints Method for ListEndpoints

List the system installed notification endpoints

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEndpointsRequest
*/
func (a *DefaultApiService) ListEndpoints(ctx context.Context) ApiListEndpointsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEndpointsRequest
*/
func (a *DefaultApiService) ListEndpoints(ctx _context.Context) ApiListEndpointsRequest {
>>>>>>> main
	return ApiListEndpointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationEndpoint
<<<<<<< HEAD
func (a *DefaultApiService) ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListEndpoints")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFileContentSearchResultsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	imageDigest string
}

<<<<<<< HEAD
func (r ApiListFileContentSearchResultsRequest) Execute() ([]FileContentSearchResult, *http.Response, error) {
=======

func (r ApiListFileContentSearchResultsRequest) Execute() ([]FileContentSearchResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListFileContentSearchResultsExecute(r)
}

/*
ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListFileContentSearchResultsRequest
*/
func (a *DefaultApiService) ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListFileContentSearchResultsRequest
*/
func (a *DefaultApiService) ListFileContentSearchResults(ctx _context.Context, imageDigest string) ApiListFileContentSearchResultsRequest {
>>>>>>> main
	return ApiListFileContentSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []FileContentSearchResult
<<<<<<< HEAD
func (a *DefaultApiService) ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []FileContentSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListFileContentSearchResults")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/file-content-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/file-content-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", _neturl.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGithubConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListGithubConfigurationsRequest) Execute() ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListGithubConfigurationsRequest) Execute() ([]NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListGithubConfigurationsExecute(r)
}

/*
ListGithubConfigurations Method for ListGithubConfigurations

List GitHub endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGithubConfigurationsRequest
*/
func (a *DefaultApiService) ListGithubConfigurations(ctx context.Context) ApiListGithubConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGithubConfigurationsRequest
*/
func (a *DefaultApiService) ListGithubConfigurations(ctx _context.Context) ApiListGithubConfigurationsRequest {
>>>>>>> main
	return ApiListGithubConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationGitHubEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationGitHubEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListGithubConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGithubSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListGithubSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListGithubSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListGithubSelectorsExecute(r)
}

/*
ListGithubSelectors Method for ListGithubSelectors

List selectors mapping events for delivery to a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListGithubSelectorsRequest
*/
func (a *DefaultApiService) ListGithubSelectors(ctx context.Context, uuid string) ApiListGithubSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListGithubSelectorsRequest
*/
func (a *DefaultApiService) ListGithubSelectors(ctx _context.Context, uuid string) ApiListGithubSelectorsRequest {
>>>>>>> main
	return ApiListGithubSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListGithubSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIdpsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListIdpsRequest) Execute() ([]string, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListIdpsRequest) Execute() ([]string, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListIdpsExecute(r)
}

/*
ListIdps Method for ListIdps

List the names of configured Identity Providers for this anchore installation

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdpsRequest
*/
func (a *DefaultApiService) ListIdps(ctx context.Context) ApiListIdpsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdpsRequest
*/
func (a *DefaultApiService) ListIdps(ctx _context.Context) ApiListIdpsRequest {
>>>>>>> main
	return ApiListIdpsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
<<<<<<< HEAD
func (a *DefaultApiService) ListIdpsExecute(r ApiListIdpsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListIdpsExecute(r ApiListIdpsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIdps")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJiraConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListJiraConfigurationsRequest) Execute() ([]NotificationJiraEndpointConfigurationBase, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListJiraConfigurationsRequest) Execute() ([]NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListJiraConfigurationsExecute(r)
}

/*
ListJiraConfigurations Method for ListJiraConfigurations

List Jira endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListJiraConfigurationsRequest
*/
func (a *DefaultApiService) ListJiraConfigurations(ctx context.Context) ApiListJiraConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListJiraConfigurationsRequest
*/
func (a *DefaultApiService) ListJiraConfigurations(ctx _context.Context) ApiListJiraConfigurationsRequest {
>>>>>>> main
	return ApiListJiraConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationJiraEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationJiraEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListJiraConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJiraSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListJiraSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListJiraSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListJiraSelectorsExecute(r)
}

/*
ListJiraSelectors Method for ListJiraSelectors

List selectors mapping events for delivery to a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListJiraSelectorsRequest
*/
func (a *DefaultApiService) ListJiraSelectors(ctx context.Context, uuid string) ApiListJiraSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListJiraSelectorsRequest
*/
func (a *DefaultApiService) ListJiraSelectors(ctx _context.Context, uuid string) ApiListJiraSelectorsRequest {
>>>>>>> main
	return ApiListJiraSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListJiraSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRetrievedFilesRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	imageDigest string
}

<<<<<<< HEAD
func (r ApiListRetrievedFilesRequest) Execute() ([]RetrievedFile, *http.Response, error) {
=======

func (r ApiListRetrievedFilesRequest) Execute() ([]RetrievedFile, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListRetrievedFilesExecute(r)
}

/*
ListRetrievedFiles Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListRetrievedFilesRequest
*/
func (a *DefaultApiService) ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListRetrievedFilesRequest
*/
func (a *DefaultApiService) ListRetrievedFiles(ctx _context.Context, imageDigest string) ApiListRetrievedFilesRequest {
>>>>>>> main
	return ApiListRetrievedFilesRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []RetrievedFile
<<<<<<< HEAD
func (a *DefaultApiService) ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []RetrievedFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRetrievedFiles")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/retrieved-files"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/retrieved-files"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", _neturl.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRoleMembersRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	roleName string
	forAccount *string
}

// Optional filter parameter to limit the set fo returned items to only those with matching account. Will return Access Denied if caller does not have permission to listRoleMembers for that account.
func (r ApiListRoleMembersRequest) ForAccount(forAccount string) ApiListRoleMembersRequest {
	r.forAccount = &forAccount
	return r
}

<<<<<<< HEAD
func (r ApiListRoleMembersRequest) Execute() ([]RbacManagerRoleMember, *http.Response, error) {
=======
func (r ApiListRoleMembersRequest) Execute() ([]RbacManagerRoleMember, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListRoleMembersExecute(r)
}

/*
ListRoleMembers Returns a list of objects that have members in the role. The list is filtered by 'listRoleMembers' access for the 'account' element of each entry.

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiListRoleMembersRequest
*/
func (a *DefaultApiService) ListRoleMembers(ctx context.Context, roleName string) ApiListRoleMembersRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiListRoleMembersRequest
*/
func (a *DefaultApiService) ListRoleMembers(ctx _context.Context, roleName string) ApiListRoleMembersRequest {
>>>>>>> main
	return ApiListRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleMember
<<<<<<< HEAD
func (a *DefaultApiService) ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []RbacManagerRoleMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoleMembers")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", _neturl.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	if r.forAccount != nil {
		localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRolesRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListRolesRequest) Execute() ([]RbacManagerRoleSummary, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListRolesRequest) Execute() ([]RbacManagerRoleSummary, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListRolesExecute(r)
}

/*
ListRoles List roles available in the system

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRolesRequest
*/
func (a *DefaultApiService) ListRoles(ctx context.Context) ApiListRolesRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRolesRequest
*/
func (a *DefaultApiService) ListRoles(ctx _context.Context) ApiListRolesRequest {
>>>>>>> main
	return ApiListRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleSummary
<<<<<<< HEAD
func (a *DefaultApiService) ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []RbacManagerRoleSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoles")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/rbac-manager/roles"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSecretSearchResultsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	imageDigest string
}

<<<<<<< HEAD
func (r ApiListSecretSearchResultsRequest) Execute() ([]SecretSearchResult, *http.Response, error) {
=======

func (r ApiListSecretSearchResultsRequest) Execute() ([]SecretSearchResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSecretSearchResultsExecute(r)
}

/*
ListSecretSearchResults Return a list of analyzer artifacts of the specified type

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListSecretSearchResultsRequest
*/
func (a *DefaultApiService) ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListSecretSearchResultsRequest
*/
func (a *DefaultApiService) ListSecretSearchResults(ctx _context.Context, imageDigest string) ApiListSecretSearchResultsRequest {
>>>>>>> main
	return ApiListSecretSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []SecretSearchResult
<<<<<<< HEAD
func (a *DefaultApiService) ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []SecretSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSecretSearchResults")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/secret-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/secret-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", _neturl.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSelectorsExecute(r)
}

/*
ListSelectors Method for ListSelectors

List all selectors mapped to endpoint configurations for the account

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSelectorsRequest
*/
func (a *DefaultApiService) ListSelectors(ctx context.Context) ApiListSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSelectorsRequest
*/
func (a *DefaultApiService) ListSelectors(ctx _context.Context) ApiListSelectorsRequest {
>>>>>>> main
	return ApiListSelectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/selectors"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSlackConfigurationsRequest) Execute() ([]NotificationSlackEndpointConfiguration, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListSlackConfigurationsRequest) Execute() ([]NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSlackConfigurationsExecute(r)
}

/*
ListSlackConfigurations Method for ListSlackConfigurations

List Slack endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSlackConfigurationsRequest
*/
func (a *DefaultApiService) ListSlackConfigurations(ctx context.Context) ApiListSlackConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSlackConfigurationsRequest
*/
func (a *DefaultApiService) ListSlackConfigurations(ctx _context.Context) ApiListSlackConfigurationsRequest {
>>>>>>> main
	return ApiListSlackConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSlackEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSlackEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSlackConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListSlackSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListSlackSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSlackSelectorsExecute(r)
}

/*
ListSlackSelectors Method for ListSlackSelectors

List selectors mapping events for delivery to a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSlackSelectorsRequest
*/
func (a *DefaultApiService) ListSlackSelectors(ctx context.Context, uuid string) ApiListSlackSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSlackSelectorsRequest
*/
func (a *DefaultApiService) ListSlackSelectors(ctx _context.Context, uuid string) ApiListSlackSelectorsRequest {
>>>>>>> main
	return ApiListSlackSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSlackSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSmtpConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSmtpConfigurationsRequest) Execute() ([]NotificationSMTPEndpointConfiguration, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListSmtpConfigurationsRequest) Execute() ([]NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSmtpConfigurationsExecute(r)
}

/*
ListSmtpConfigurations Method for ListSmtpConfigurations

List SMTP endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSmtpConfigurationsRequest
*/
func (a *DefaultApiService) ListSmtpConfigurations(ctx context.Context) ApiListSmtpConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSmtpConfigurationsRequest
*/
func (a *DefaultApiService) ListSmtpConfigurations(ctx _context.Context) ApiListSmtpConfigurationsRequest {
>>>>>>> main
	return ApiListSmtpConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSMTPEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSMTPEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSmtpConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSmtpSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListSmtpSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListSmtpSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListSmtpSelectorsExecute(r)
}

/*
ListSmtpSelectors Method for ListSmtpSelectors

List selectors mapping events for delivery to a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSmtpSelectorsRequest
*/
func (a *DefaultApiService) ListSmtpSelectors(ctx context.Context, uuid string) ApiListSmtpSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSmtpSelectorsRequest
*/
func (a *DefaultApiService) ListSmtpSelectors(ctx _context.Context, uuid string) ApiListSmtpSelectorsRequest {
>>>>>>> main
	return ApiListSmtpSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSmtpSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTeamsConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListTeamsConfigurationsRequest) Execute() ([]NotificationTeamsEndpointConfiguration, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListTeamsConfigurationsRequest) Execute() ([]NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListTeamsConfigurationsExecute(r)
}

/*
ListTeamsConfigurations Method for ListTeamsConfigurations

List Teams endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTeamsConfigurationsRequest
*/
func (a *DefaultApiService) ListTeamsConfigurations(ctx context.Context) ApiListTeamsConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTeamsConfigurationsRequest
*/
func (a *DefaultApiService) ListTeamsConfigurations(ctx _context.Context) ApiListTeamsConfigurationsRequest {
>>>>>>> main
	return ApiListTeamsConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationTeamsEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationTeamsEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTeamsConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTeamsSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListTeamsSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListTeamsSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListTeamsSelectorsExecute(r)
}

/*
ListTeamsSelectors Method for ListTeamsSelectors

List selectors mapping events for delivery to a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListTeamsSelectorsRequest
*/
func (a *DefaultApiService) ListTeamsSelectors(ctx context.Context, uuid string) ApiListTeamsSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListTeamsSelectorsRequest
*/
func (a *DefaultApiService) ListTeamsSelectors(ctx _context.Context, uuid string) ApiListTeamsSelectorsRequest {
>>>>>>> main
	return ApiListTeamsSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTeamsSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUserRolesRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	username string
	forAccount *string
	role *string
}

func (r ApiListUserRolesRequest) ForAccount(forAccount string) ApiListUserRolesRequest {
	r.forAccount = &forAccount
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
func (r ApiListUserRolesRequest) Role(role string) ApiListUserRolesRequest {
	r.role = &role
	return r
}

<<<<<<< HEAD
func (r ApiListUserRolesRequest) Execute() ([]RbacManagerRoleMembership, *http.Response, error) {
=======
func (r ApiListUserRolesRequest) Execute() ([]RbacManagerRoleMembership, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListUserRolesExecute(r)
}

/*
ListUserRoles List the roles for which the requested user is a member

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiListUserRolesRequest
*/
func (a *DefaultApiService) ListUserRoles(ctx context.Context, username string) ApiListUserRolesRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiListUserRolesRequest
*/
func (a *DefaultApiService) ListUserRoles(ctx _context.Context, username string) ApiListUserRolesRequest {
>>>>>>> main
	return ApiListUserRolesRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleMembership
<<<<<<< HEAD
func (a *DefaultApiService) ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []RbacManagerRoleMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUserRoles")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/users/{username}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/users/{username}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", _neturl.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	if r.forAccount != nil {
		localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWebhookConfigurationsRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListWebhookConfigurationsRequest) Execute() ([]NotificationWebhookEndpointConfiguration, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListWebhookConfigurationsRequest) Execute() ([]NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListWebhookConfigurationsExecute(r)
}

/*
ListWebhookConfigurations Method for ListWebhookConfigurations

List Webhook endpoint configurations

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListWebhookConfigurationsRequest
*/
func (a *DefaultApiService) ListWebhookConfigurations(ctx context.Context) ApiListWebhookConfigurationsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListWebhookConfigurationsRequest
*/
func (a *DefaultApiService) ListWebhookConfigurations(ctx _context.Context) ApiListWebhookConfigurationsRequest {
>>>>>>> main
	return ApiListWebhookConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationWebhookEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationWebhookEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWebhookConfigurations")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWebhookSelectorsRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiListWebhookSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
=======

func (r ApiListWebhookSelectorsRequest) Execute() ([]NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.ListWebhookSelectorsExecute(r)
}

/*
ListWebhookSelectors Method for ListWebhookSelectors

List selectors mapping events for delivery to a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListWebhookSelectorsRequest
*/
func (a *DefaultApiService) ListWebhookSelectors(ctx context.Context, uuid string) ApiListWebhookSelectorsRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListWebhookSelectorsRequest
*/
func (a *DefaultApiService) ListWebhookSelectors(ctx _context.Context, uuid string) ApiListWebhookSelectorsRequest {
>>>>>>> main
	return ApiListWebhookSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWebhookSelectors")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMyRolesRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiMyRolesRequest) Execute() ([]RbacManagerAccountRole, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiMyRolesRequest) Execute() ([]RbacManagerAccountRole, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.MyRolesExecute(r)
}

/*
MyRoles List the roles for which the authenticated user is a member

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMyRolesRequest
*/
func (a *DefaultApiService) MyRoles(ctx context.Context) ApiMyRolesRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMyRolesRequest
*/
func (a *DefaultApiService) MyRoles(ctx _context.Context) ApiMyRolesRequest {
>>>>>>> main
	return ApiMyRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RbacManagerAccountRole
<<<<<<< HEAD
func (a *DefaultApiService) MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  []RbacManagerAccountRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MyRoles")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/rbac-manager/my-roles"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiPingRequest) Execute() (string, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiPingRequest) Execute() (string, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.PingExecute(r)
}

/*
Ping Method for Ping

Simple status check

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *DefaultApiService) Ping(ctx context.Context) ApiPingRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *DefaultApiService) Ping(ctx _context.Context) ApiPingRequest {
>>>>>>> main
	return ApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
<<<<<<< HEAD
func (a *DefaultApiService) PingExecute(r ApiPingRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) PingExecute(r ApiPingRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ping")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeOauthTokenRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	token *string
	tokenTypeHint *string
}

// The token to be revoked
func (r ApiRevokeOauthTokenRequest) Token(token string) ApiRevokeOauthTokenRequest {
	r.token = &token
	return r
}
<<<<<<< HEAD

=======
>>>>>>> main
// A hint about the type of token to be revoked
func (r ApiRevokeOauthTokenRequest) TokenTypeHint(tokenTypeHint string) ApiRevokeOauthTokenRequest {
	r.tokenTypeHint = &tokenTypeHint
	return r
}

<<<<<<< HEAD
func (r ApiRevokeOauthTokenRequest) Execute() (*http.Response, error) {
=======
func (r ApiRevokeOauthTokenRequest) Execute() (*_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.RevokeOauthTokenExecute(r)
}

/*
RevokeOauthToken Method for RevokeOauthToken

Revoke a refresh token previously requested from /oauth/token

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeOauthTokenRequest
*/
func (a *DefaultApiService) RevokeOauthToken(ctx context.Context) ApiRevokeOauthTokenRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeOauthTokenRequest
*/
func (a *DefaultApiService) RevokeOauthToken(ctx _context.Context) ApiRevokeOauthTokenRequest {
>>>>>>> main
	return ApiRevokeOauthTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
<<<<<<< HEAD
func (a *DefaultApiService) RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
=======
func (a *DefaultApiService) RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RevokeOauthToken")
	if err != nil {
<<<<<<< HEAD
		return nil, &GenericOpenAPIError{error: err.Error()}
=======
		return nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/oauth/revoke"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarFormParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.tokenTypeHint != nil {
		localVarFormParams.Add("token_type_hint", parameterToString(*r.tokenTypeHint, ""))
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
<<<<<<< HEAD
			var v RevokeOauthToken400Response
=======
			var v InlineResponse400
>>>>>>> main
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSamlLoginRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	idpName string
}

<<<<<<< HEAD
func (r ApiSamlLoginRequest) Execute() (*RbacManagerTokenResponse, *http.Response, error) {
=======

func (r ApiSamlLoginRequest) Execute() (RbacManagerTokenResponse, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.SamlLoginExecute(r)
}

/*
SamlLogin Method for SamlLogin

Initiate an SP-initiated login sequence for the Idp. The SP will respond with the SAML AuthN Request the client must send to the Idp URL

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlLoginRequest
*/
func (a *DefaultApiService) SamlLogin(ctx context.Context, idpName string) ApiSamlLoginRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlLoginRequest
*/
func (a *DefaultApiService) SamlLogin(ctx _context.Context, idpName string) ApiSamlLoginRequest {
>>>>>>> main
	return ApiSamlLoginRequest{
		ApiService: a,
		ctx: ctx,
		idpName: idpName,
	}
}

// Execute executes the request
//  @return RbacManagerTokenResponse
<<<<<<< HEAD
func (a *DefaultApiService) SamlLoginExecute(r ApiSamlLoginRequest) (*RbacManagerTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerTokenResponse
=======
func (a *DefaultApiService) SamlLoginExecute(r ApiSamlLoginRequest) (RbacManagerTokenResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerTokenResponse
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SamlLogin")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/login/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", url.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/login/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", _neturl.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSamlSsoRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	idpName string
}

<<<<<<< HEAD
func (r ApiSamlSsoRequest) Execute() (*RbacManagerTokenResponse, *http.Response, error) {
=======

func (r ApiSamlSsoRequest) Execute() (RbacManagerTokenResponse, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.SamlSsoExecute(r)
}

/*
SamlSso Method for SamlSso

Perform a login using a SAML assertion, no HTTP auth is required as the SAML assertion is considered the authenticating token

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlSsoRequest
*/
func (a *DefaultApiService) SamlSso(ctx context.Context, idpName string) ApiSamlSsoRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlSsoRequest
*/
func (a *DefaultApiService) SamlSso(ctx _context.Context, idpName string) ApiSamlSsoRequest {
>>>>>>> main
	return ApiSamlSsoRequest{
		ApiService: a,
		ctx: ctx,
		idpName: idpName,
	}
}

// Execute executes the request
//  @return RbacManagerTokenResponse
<<<<<<< HEAD
func (a *DefaultApiService) SamlSsoExecute(r ApiSamlSsoRequest) (*RbacManagerTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerTokenResponse
=======
func (a *DefaultApiService) SamlSsoExecute(r ApiSamlSsoRequest) (RbacManagerTokenResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerTokenResponse
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SamlSso")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/sso/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", url.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/sso/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", _neturl.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationGitHubEndpointConfigurationPost
}

func (r ApiTestGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPost) ApiTestGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestGithubConfigurationRequest) Execute() (*NotificationGitHubTestResult, *http.Response, error) {
=======
func (r ApiTestGithubConfigurationRequest) Execute() (NotificationGitHubTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestGithubConfigurationExecute(r)
}

/*
TestGithubConfiguration Method for TestGithubConfiguration

Test GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestGithubConfigurationRequest
*/
func (a *DefaultApiService) TestGithubConfiguration(ctx context.Context) ApiTestGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestGithubConfigurationRequest
*/
func (a *DefaultApiService) TestGithubConfiguration(ctx _context.Context) ApiTestGithubConfigurationRequest {
>>>>>>> main
	return ApiTestGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationGitHubTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubTestResult
=======
func (a *DefaultApiService) TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (NotificationGitHubTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationGitHubTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationJiraEndpointConfigurationPost
}

func (r ApiTestJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPost) ApiTestJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestJiraConfigurationRequest) Execute() (*NotificationJiraTestResult, *http.Response, error) {
=======
func (r ApiTestJiraConfigurationRequest) Execute() (NotificationJiraTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestJiraConfigurationExecute(r)
}

/*
TestJiraConfiguration Method for TestJiraConfiguration

Test Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestJiraConfigurationRequest
*/
func (a *DefaultApiService) TestJiraConfiguration(ctx context.Context) ApiTestJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestJiraConfigurationRequest
*/
func (a *DefaultApiService) TestJiraConfiguration(ctx _context.Context) ApiTestJiraConfigurationRequest {
>>>>>>> main
	return ApiTestJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationJiraTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraTestResult
=======
func (a *DefaultApiService) TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (NotificationJiraTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationJiraTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiTestSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiTestSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestSlackConfigurationRequest) Execute() (*NotificationSlackTestResult, *http.Response, error) {
=======
func (r ApiTestSlackConfigurationRequest) Execute() (NotificationSlackTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestSlackConfigurationExecute(r)
}

/*
TestSlackConfiguration Method for TestSlackConfiguration

Test Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSlackConfigurationRequest
*/
func (a *DefaultApiService) TestSlackConfiguration(ctx context.Context) ApiTestSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSlackConfigurationRequest
*/
func (a *DefaultApiService) TestSlackConfiguration(ctx _context.Context) ApiTestSlackConfigurationRequest {
>>>>>>> main
	return ApiTestSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSlackTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackTestResult
=======
func (a *DefaultApiService) TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (NotificationSlackTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSlackTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiTestSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiTestSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestSmtpConfigurationRequest) Execute() (*NotificationSMTPTestResult, *http.Response, error) {
=======
func (r ApiTestSmtpConfigurationRequest) Execute() (NotificationSMTPTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestSmtpConfigurationExecute(r)
}

/*
TestSmtpConfiguration Method for TestSmtpConfiguration

Test SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestSmtpConfiguration(ctx context.Context) ApiTestSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestSmtpConfiguration(ctx _context.Context) ApiTestSmtpConfigurationRequest {
>>>>>>> main
	return ApiTestSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSMTPTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPTestResult
=======
func (a *DefaultApiService) TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (NotificationSMTPTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSMTPTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredGithubConfigurationRequest) Execute() (*NotificationGitHubTestResult, *http.Response, error) {
=======

func (r ApiTestStoredGithubConfigurationRequest) Execute() (NotificationGitHubTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredGithubConfigurationExecute(r)
}

/*
TestStoredGithubConfiguration Method for TestStoredGithubConfiguration

Test stored GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredGithubConfigurationRequest
*/
func (a *DefaultApiService) TestStoredGithubConfiguration(ctx context.Context, uuid string) ApiTestStoredGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredGithubConfigurationRequest
*/
func (a *DefaultApiService) TestStoredGithubConfiguration(ctx _context.Context, uuid string) ApiTestStoredGithubConfigurationRequest {
>>>>>>> main
	return ApiTestStoredGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubTestResult
=======
func (a *DefaultApiService) TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (NotificationGitHubTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationGitHubTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredJiraConfigurationRequest) Execute() (*NotificationJiraTestResult, *http.Response, error) {
=======

func (r ApiTestStoredJiraConfigurationRequest) Execute() (NotificationJiraTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredJiraConfigurationExecute(r)
}

/*
TestStoredJiraConfiguration Method for TestStoredJiraConfiguration

Test stored Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredJiraConfigurationRequest
*/
func (a *DefaultApiService) TestStoredJiraConfiguration(ctx context.Context, uuid string) ApiTestStoredJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredJiraConfigurationRequest
*/
func (a *DefaultApiService) TestStoredJiraConfiguration(ctx _context.Context, uuid string) ApiTestStoredJiraConfigurationRequest {
>>>>>>> main
	return ApiTestStoredJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraTestResult
=======
func (a *DefaultApiService) TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (NotificationJiraTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationJiraTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredSlackConfigurationRequest) Execute() (*NotificationSlackTestResult, *http.Response, error) {
=======

func (r ApiTestStoredSlackConfigurationRequest) Execute() (NotificationSlackTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredSlackConfigurationExecute(r)
}

/*
TestStoredSlackConfiguration Method for TestStoredSlackConfiguration

Test stored Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSlackConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSlackConfiguration(ctx context.Context, uuid string) ApiTestStoredSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSlackConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSlackConfiguration(ctx _context.Context, uuid string) ApiTestStoredSlackConfigurationRequest {
>>>>>>> main
	return ApiTestStoredSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackTestResult
=======
func (a *DefaultApiService) TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (NotificationSlackTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSlackTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredSmtpConfigurationRequest) Execute() (*NotificationSMTPTestResult, *http.Response, error) {
=======

func (r ApiTestStoredSmtpConfigurationRequest) Execute() (NotificationSMTPTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredSmtpConfigurationExecute(r)
}

/*
TestStoredSmtpConfiguration Method for TestStoredSmtpConfiguration

Test stored SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSmtpConfiguration(ctx context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSmtpConfiguration(ctx _context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest {
>>>>>>> main
	return ApiTestStoredSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPTestResult
=======
func (a *DefaultApiService) TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (NotificationSMTPTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSMTPTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredTeamsConfigurationRequest) Execute() (*NotificationTeamsTestResult, *http.Response, error) {
=======

func (r ApiTestStoredTeamsConfigurationRequest) Execute() (NotificationTeamsTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredTeamsConfigurationExecute(r)
}

/*
TestStoredTeamsConfiguration Method for TestStoredTeamsConfiguration

Test stored Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestStoredTeamsConfiguration(ctx context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestStoredTeamsConfiguration(ctx _context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest {
>>>>>>> main
	return ApiTestStoredTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsTestResult
=======
func (a *DefaultApiService) TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (NotificationTeamsTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationTeamsTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
}

<<<<<<< HEAD
func (r ApiTestStoredWebhookConfigurationRequest) Execute() (*NotificationWebhookTestResult, *http.Response, error) {
=======

func (r ApiTestStoredWebhookConfigurationRequest) Execute() (NotificationWebhookTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestStoredWebhookConfigurationExecute(r)
}

/*
TestStoredWebhookConfiguration Method for TestStoredWebhookConfiguration

Test stored Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestStoredWebhookConfiguration(ctx context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestStoredWebhookConfiguration(ctx _context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest {
>>>>>>> main
	return ApiTestStoredWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookTestResult
=======
func (a *DefaultApiService) TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (NotificationWebhookTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiTestTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiTestTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestTeamsConfigurationRequest) Execute() (*NotificationTeamsTestResult, *http.Response, error) {
=======
func (r ApiTestTeamsConfigurationRequest) Execute() (NotificationTeamsTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestTeamsConfigurationExecute(r)
}

/*
TestTeamsConfiguration Method for TestTeamsConfiguration

Test Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestTeamsConfiguration(ctx context.Context) ApiTestTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestTeamsConfiguration(ctx _context.Context) ApiTestTeamsConfigurationRequest {
>>>>>>> main
	return ApiTestTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTeamsTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsTestResult
=======
func (a *DefaultApiService) TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (NotificationTeamsTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationTeamsTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiTestWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiTestWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiTestWebhookConfigurationRequest) Execute() (*NotificationWebhookTestResult, *http.Response, error) {
=======
func (r ApiTestWebhookConfigurationRequest) Execute() (NotificationWebhookTestResult, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.TestWebhookConfigurationExecute(r)
}

/*
TestWebhookConfiguration Method for TestWebhookConfiguration

Test Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestWebhookConfiguration(ctx context.Context) ApiTestWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestWebhookConfiguration(ctx _context.Context) ApiTestWebhookConfigurationRequest {
>>>>>>> main
	return ApiTestWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationWebhookTestResult
<<<<<<< HEAD
func (a *DefaultApiService) TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookTestResult
=======
func (a *DefaultApiService) TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (NotificationWebhookTestResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookTestResult
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/test"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEndpointStatusRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	name string
	status *NotificationEndpointEnabledStatus
}

func (r ApiUpdateEndpointStatusRequest) Status(status NotificationEndpointEnabledStatus) ApiUpdateEndpointStatusRequest {
	r.status = &status
	return r
}

<<<<<<< HEAD
func (r ApiUpdateEndpointStatusRequest) Execute() (*NotificationEndpointEnabledStatus, *http.Response, error) {
=======
func (r ApiUpdateEndpointStatusRequest) Execute() (NotificationEndpointEnabledStatus, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateEndpointStatusExecute(r)
}

/*
UpdateEndpointStatus Method for UpdateEndpointStatus

Update enabled status of an endpoint

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateEndpointStatusRequest
*/
func (a *DefaultApiService) UpdateEndpointStatus(ctx context.Context, name string) ApiUpdateEndpointStatusRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateEndpointStatusRequest
*/
func (a *DefaultApiService) UpdateEndpointStatus(ctx _context.Context, name string) ApiUpdateEndpointStatusRequest {
>>>>>>> main
	return ApiUpdateEndpointStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return NotificationEndpointEnabledStatus
<<<<<<< HEAD
func (a *DefaultApiService) UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (*NotificationEndpointEnabledStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationEndpointEnabledStatus
=======
func (a *DefaultApiService) UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (NotificationEndpointEnabledStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationEndpointEnabledStatus
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateEndpointStatus")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.status
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGithubConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationGitHubEndpointConfigurationPut
}

func (r ApiUpdateGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPut) ApiUpdateGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
=======
func (r ApiUpdateGithubConfigurationRequest) Execute() (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateGithubConfigurationExecute(r)
}

/*
UpdateGithubConfiguration Method for UpdateGithubConfiguration

Update a GitHub endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateGithubConfigurationRequest
*/
func (a *DefaultApiService) UpdateGithubConfiguration(ctx context.Context, uuid string) ApiUpdateGithubConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateGithubConfigurationRequest
*/
func (a *DefaultApiService) UpdateGithubConfiguration(ctx _context.Context, uuid string) ApiUpdateGithubConfigurationRequest {
>>>>>>> main
	return ApiUpdateGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
=======
func (a *DefaultApiService) UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (NotificationGitHubEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationGitHubEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGithubConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGithubSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateGithubSelectorRequest) Selector(selector NotificationSelector) ApiUpdateGithubSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateGithubSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateGithubSelectorExecute(r)
}

/*
UpdateGithubSelector Method for UpdateGithubSelector

Update a selector mapped to a GitHub endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateGithubSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest {
=======
func (a *DefaultApiService) UpdateGithubSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest {
>>>>>>> main
	return ApiUpdateGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGithubSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIdpRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	name string
	configuration *RbacManagerSamlConfiguration
}

func (r ApiUpdateIdpRequest) Configuration(configuration RbacManagerSamlConfiguration) ApiUpdateIdpRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
=======
func (r ApiUpdateIdpRequest) Execute() (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateIdpExecute(r)
}

/*
UpdateIdp Method for UpdateIdp

Update an existing Identity Provider configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateIdpRequest
*/
func (a *DefaultApiService) UpdateIdp(ctx context.Context, name string) ApiUpdateIdpRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateIdpRequest
*/
func (a *DefaultApiService) UpdateIdp(ctx _context.Context, name string) ApiUpdateIdpRequest {
>>>>>>> main
	return ApiUpdateIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) UpdateIdpExecute(r ApiUpdateIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
=======
func (a *DefaultApiService) UpdateIdpExecute(r ApiUpdateIdpRequest) (RbacManagerSamlConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RbacManagerSamlConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIdp")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJiraConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationJiraEndpointConfigurationPut
}

func (r ApiUpdateJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPut) ApiUpdateJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
=======
func (r ApiUpdateJiraConfigurationRequest) Execute() (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateJiraConfigurationExecute(r)
}

/*
UpdateJiraConfiguration Method for UpdateJiraConfiguration

Update a Jira endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateJiraConfigurationRequest
*/
func (a *DefaultApiService) UpdateJiraConfiguration(ctx context.Context, uuid string) ApiUpdateJiraConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateJiraConfigurationRequest
*/
func (a *DefaultApiService) UpdateJiraConfiguration(ctx _context.Context, uuid string) ApiUpdateJiraConfigurationRequest {
>>>>>>> main
	return ApiUpdateJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
<<<<<<< HEAD
func (a *DefaultApiService) UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
=======
func (a *DefaultApiService) UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (NotificationJiraEndpointConfigurationBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationJiraEndpointConfigurationBase
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateJiraConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJiraSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateJiraSelectorRequest) Selector(selector NotificationSelector) ApiUpdateJiraSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateJiraSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateJiraSelectorExecute(r)
}

/*
UpdateJiraSelector Method for UpdateJiraSelector

Update a selector mapped to a Jira endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateJiraSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest {
=======
func (a *DefaultApiService) UpdateJiraSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest {
>>>>>>> main
	return ApiUpdateJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateJiraSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSlackConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiUpdateSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiUpdateSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
=======
func (r ApiUpdateSlackConfigurationRequest) Execute() (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateSlackConfigurationExecute(r)
}

/*
UpdateSlackConfiguration Method for UpdateSlackConfiguration

Update a Slack endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSlackConfigurationRequest
*/
func (a *DefaultApiService) UpdateSlackConfiguration(ctx context.Context, uuid string) ApiUpdateSlackConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSlackConfigurationRequest
*/
func (a *DefaultApiService) UpdateSlackConfiguration(ctx _context.Context, uuid string) ApiUpdateSlackConfigurationRequest {
>>>>>>> main
	return ApiUpdateSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
=======
func (a *DefaultApiService) UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (NotificationSlackEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSlackEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSlackConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSlackSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateSlackSelectorRequest) Selector(selector NotificationSelector) ApiUpdateSlackSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateSlackSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateSlackSelectorExecute(r)
}

/*
UpdateSlackSelector Method for UpdateSlackSelector

Update a selector mapped to a Slack endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateSlackSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest {
=======
func (a *DefaultApiService) UpdateSlackSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest {
>>>>>>> main
	return ApiUpdateSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSlackSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSmtpConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiUpdateSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiUpdateSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
=======
func (r ApiUpdateSmtpConfigurationRequest) Execute() (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateSmtpConfigurationExecute(r)
}

/*
UpdateSmtpConfiguration Method for UpdateSmtpConfiguration

Update a SMTP endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSmtpConfigurationRequest
*/
func (a *DefaultApiService) UpdateSmtpConfiguration(ctx context.Context, uuid string) ApiUpdateSmtpConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSmtpConfigurationRequest
*/
func (a *DefaultApiService) UpdateSmtpConfiguration(ctx _context.Context, uuid string) ApiUpdateSmtpConfigurationRequest {
>>>>>>> main
	return ApiUpdateSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
=======
func (a *DefaultApiService) UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (NotificationSMTPEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSMTPEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSmtpConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSmtpSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateSmtpSelectorRequest) Selector(selector NotificationSelector) ApiUpdateSmtpSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateSmtpSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateSmtpSelectorExecute(r)
}

/*
UpdateSmtpSelector Method for UpdateSmtpSelector

Update a selector mapped to a SMTP endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateSmtpSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest {
=======
func (a *DefaultApiService) UpdateSmtpSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest {
>>>>>>> main
	return ApiUpdateSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSmtpSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeamsConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiUpdateTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiUpdateTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
=======
func (r ApiUpdateTeamsConfigurationRequest) Execute() (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateTeamsConfigurationExecute(r)
}

/*
UpdateTeamsConfiguration Method for UpdateTeamsConfiguration

Update a Teams endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateTeamsConfigurationRequest
*/
func (a *DefaultApiService) UpdateTeamsConfiguration(ctx context.Context, uuid string) ApiUpdateTeamsConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateTeamsConfigurationRequest
*/
func (a *DefaultApiService) UpdateTeamsConfiguration(ctx _context.Context, uuid string) ApiUpdateTeamsConfigurationRequest {
>>>>>>> main
	return ApiUpdateTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
=======
func (a *DefaultApiService) UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (NotificationTeamsEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationTeamsEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTeamsConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeamsSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateTeamsSelectorRequest) Selector(selector NotificationSelector) ApiUpdateTeamsSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateTeamsSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateTeamsSelectorExecute(r)
}

/*
UpdateTeamsSelector Method for UpdateTeamsSelector

Update a selector mapped to a Teams endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateTeamsSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest {
=======
func (a *DefaultApiService) UpdateTeamsSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest {
>>>>>>> main
	return ApiUpdateTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTeamsSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookConfigurationRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	uuid string
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiUpdateWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiUpdateWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

<<<<<<< HEAD
func (r ApiUpdateWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
=======
func (r ApiUpdateWebhookConfigurationRequest) Execute() (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateWebhookConfigurationExecute(r)
}

/*
UpdateWebhookConfiguration Method for UpdateWebhookConfiguration

Update a Webhook endpoint configuration by it's UUID

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateWebhookConfigurationRequest
*/
func (a *DefaultApiService) UpdateWebhookConfiguration(ctx context.Context, uuid string) ApiUpdateWebhookConfigurationRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateWebhookConfigurationRequest
*/
func (a *DefaultApiService) UpdateWebhookConfiguration(ctx _context.Context, uuid string) ApiUpdateWebhookConfigurationRequest {
>>>>>>> main
	return ApiUpdateWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
<<<<<<< HEAD
func (a *DefaultApiService) UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
=======
func (a *DefaultApiService) UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (NotificationWebhookEndpointConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationWebhookEndpointConfiguration
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateWebhookConfiguration")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookSelectorRequest struct {
<<<<<<< HEAD
	ctx context.Context
=======
	ctx _context.Context
>>>>>>> main
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateWebhookSelectorRequest) Selector(selector NotificationSelector) ApiUpdateWebhookSelectorRequest {
	r.selector = &selector
	return r
}

<<<<<<< HEAD
func (r ApiUpdateWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
=======
func (r ApiUpdateWebhookSelectorRequest) Execute() (NotificationSelector, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.UpdateWebhookSelectorExecute(r)
}

/*
UpdateWebhookSelector Method for UpdateWebhookSelector

Update a selector mapped to a Webhook endpoint configuration

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
>>>>>>> main
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateWebhookSelectorRequest
*/
<<<<<<< HEAD
func (a *DefaultApiService) UpdateWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest {
=======
func (a *DefaultApiService) UpdateWebhookSelector(ctx _context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest {
>>>>>>> main
	return ApiUpdateWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
<<<<<<< HEAD
func (a *DefaultApiService) UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
=======
func (a *DefaultApiService) UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (NotificationSelector, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationSelector
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateWebhookSelector")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", _neturl.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", _neturl.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVersionCheckRequest struct {
<<<<<<< HEAD
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiVersionCheckRequest) Execute() (*ServiceVersion, *http.Response, error) {
=======
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiVersionCheckRequest) Execute() (ServiceVersion, *_nethttp.Response, error) {
>>>>>>> main
	return r.ApiService.VersionCheckExecute(r)
}

/*
VersionCheck Method for VersionCheck

Returns the version object for the service, including db schema version info

<<<<<<< HEAD
 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVersionCheckRequest
*/
func (a *DefaultApiService) VersionCheck(ctx context.Context) ApiVersionCheckRequest {
=======
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVersionCheckRequest
*/
func (a *DefaultApiService) VersionCheck(ctx _context.Context) ApiVersionCheckRequest {
>>>>>>> main
	return ApiVersionCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceVersion
<<<<<<< HEAD
func (a *DefaultApiService) VersionCheckExecute(r ApiVersionCheckRequest) (*ServiceVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceVersion
=======
func (a *DefaultApiService) VersionCheckExecute(r ApiVersionCheckRequest) (ServiceVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ServiceVersion
>>>>>>> main
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VersionCheck")
	if err != nil {
<<<<<<< HEAD
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
=======
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
>>>>>>> main
	}

	localVarPath := localBasePath + "/version"

	localVarHeaderParams := make(map[string]string)
<<<<<<< HEAD
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
=======
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
>>>>>>> main

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
<<<<<<< HEAD
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
=======
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
>>>>>>> main
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

<<<<<<< HEAD
	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
=======
	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
>>>>>>> main
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
<<<<<<< HEAD
		newErr := &GenericOpenAPIError{
=======
		newErr := GenericOpenAPIError{
>>>>>>> main
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
