/*
Anchore API

This is the Anchore API. Provides the external API for users of Anchore Enterprise.

API version: 2.0.0
Contact: dev@anchore.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package enterprise

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type DefaultApi interface {

	/*
	AddGithubConfiguration Method for AddGithubConfiguration

	Create a new GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddGithubConfigurationRequest
	*/
	AddGithubConfiguration(ctx context.Context) ApiAddGithubConfigurationRequest

	// AddGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)

	/*
	AddGithubSelector Method for AddGithubSelector

	Add selector for mapping events for delivery to a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddGithubSelectorRequest
	*/
	AddGithubSelector(ctx context.Context, uuid string) ApiAddGithubSelectorRequest

	// AddGithubSelectorExecute executes the request
	//  @return NotificationSelector
	AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	AddIdp Method for AddIdp

	Add a new Identity Provider to the system, with a specific name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddIdpRequest
	*/
	AddIdp(ctx context.Context) ApiAddIdpRequest

	// AddIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	AddIdpExecute(r ApiAddIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)

	/*
	AddJiraConfiguration Method for AddJiraConfiguration

	Create a new Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddJiraConfigurationRequest
	*/
	AddJiraConfiguration(ctx context.Context) ApiAddJiraConfigurationRequest

	// AddJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)

	/*
	AddJiraSelector Method for AddJiraSelector

	Add selector for mapping events for delivery to a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddJiraSelectorRequest
	*/
	AddJiraSelector(ctx context.Context, uuid string) ApiAddJiraSelectorRequest

	// AddJiraSelectorExecute executes the request
	//  @return NotificationSelector
	AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	AddRoleUser Add a user to the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiAddRoleUserRequest
	*/
	AddRoleUser(ctx context.Context, roleName string) ApiAddRoleUserRequest

	// AddRoleUserExecute executes the request
	//  @return RbacManagerRoleMember
	AddRoleUserExecute(r ApiAddRoleUserRequest) (*RbacManagerRoleMember, *http.Response, error)

	/*
	AddSlackConfiguration Method for AddSlackConfiguration

	Create a new Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddSlackConfigurationRequest
	*/
	AddSlackConfiguration(ctx context.Context) ApiAddSlackConfigurationRequest

	// AddSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)

	/*
	AddSlackSelector Method for AddSlackSelector

	Add selector for mapping events for delivery to a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddSlackSelectorRequest
	*/
	AddSlackSelector(ctx context.Context, uuid string) ApiAddSlackSelectorRequest

	// AddSlackSelectorExecute executes the request
	//  @return NotificationSelector
	AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	AddSmtpConfiguration Method for AddSmtpConfiguration

	Create a new SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddSmtpConfigurationRequest
	*/
	AddSmtpConfiguration(ctx context.Context) ApiAddSmtpConfigurationRequest

	// AddSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)

	/*
	AddSmtpSelector Method for AddSmtpSelector

	Add selector for mapping events for delivery to a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddSmtpSelectorRequest
	*/
	AddSmtpSelector(ctx context.Context, uuid string) ApiAddSmtpSelectorRequest

	// AddSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	AddTeamsConfiguration Method for AddTeamsConfiguration

	Create a new Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddTeamsConfigurationRequest
	*/
	AddTeamsConfiguration(ctx context.Context) ApiAddTeamsConfigurationRequest

	// AddTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)

	/*
	AddTeamsSelector Method for AddTeamsSelector

	Add selector for mapping events for delivery to a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddTeamsSelectorRequest
	*/
	AddTeamsSelector(ctx context.Context, uuid string) ApiAddTeamsSelectorRequest

	// AddTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	AddWebhookConfiguration Method for AddWebhookConfiguration

	Create a new Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddWebhookConfigurationRequest
	*/
	AddWebhookConfiguration(ctx context.Context) ApiAddWebhookConfigurationRequest

	// AddWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)

	/*
	AddWebhookSelector Method for AddWebhookSelector

	Add selector for mapping events for delivery to a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiAddWebhookSelectorRequest
	*/
	AddWebhookSelector(ctx context.Context, uuid string) ApiAddWebhookSelectorRequest

	// AddWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	DeleteGithubConfiguration Method for DeleteGithubConfiguration

	Delete a GitHub endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteGithubConfigurationRequest
	*/
	DeleteGithubConfiguration(ctx context.Context, uuid string) ApiDeleteGithubConfigurationRequest

	// DeleteGithubConfigurationExecute executes the request
	DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*http.Response, error)

	/*
	DeleteGithubSelector Method for DeleteGithubSelector

	Delete a selector mapped to a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteGithubSelectorRequest
	*/
	DeleteGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest

	// DeleteGithubSelectorExecute executes the request
	DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*http.Response, error)

	/*
	DeleteIdp Method for DeleteIdp

	Delete an idp configuration. Users will not longer be able to login from this idp. In addition, any users that have been configured explicitly or JIT Provisioned on this IDP will be deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiDeleteIdpRequest
	*/
	DeleteIdp(ctx context.Context, name string) ApiDeleteIdpRequest

	// DeleteIdpExecute executes the request
	DeleteIdpExecute(r ApiDeleteIdpRequest) (*http.Response, error)

	/*
	DeleteJiraConfiguration Method for DeleteJiraConfiguration

	Delete a Jira endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteJiraConfigurationRequest
	*/
	DeleteJiraConfiguration(ctx context.Context, uuid string) ApiDeleteJiraConfigurationRequest

	// DeleteJiraConfigurationExecute executes the request
	DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*http.Response, error)

	/*
	DeleteJiraSelector Method for DeleteJiraSelector

	Delete a selector mapped to a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteJiraSelectorRequest
	*/
	DeleteJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest

	// DeleteJiraSelectorExecute executes the request
	DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*http.Response, error)

	/*
	DeleteRoleUser Remove a user from the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiDeleteRoleUserRequest
	*/
	DeleteRoleUser(ctx context.Context, roleName string) ApiDeleteRoleUserRequest

	// DeleteRoleUserExecute executes the request
	DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*http.Response, error)

	/*
	DeleteSlackConfiguration Method for DeleteSlackConfiguration

	Delete a Slack endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteSlackConfigurationRequest
	*/
	DeleteSlackConfiguration(ctx context.Context, uuid string) ApiDeleteSlackConfigurationRequest

	// DeleteSlackConfigurationExecute executes the request
	DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*http.Response, error)

	/*
	DeleteSlackSelector Method for DeleteSlackSelector

	Delete a selector mapped to a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteSlackSelectorRequest
	*/
	DeleteSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest

	// DeleteSlackSelectorExecute executes the request
	DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*http.Response, error)

	/*
	DeleteSmtpConfiguration Method for DeleteSmtpConfiguration

	Delete a SMTP endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteSmtpConfigurationRequest
	*/
	DeleteSmtpConfiguration(ctx context.Context, uuid string) ApiDeleteSmtpConfigurationRequest

	// DeleteSmtpConfigurationExecute executes the request
	DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*http.Response, error)

	/*
	DeleteSmtpSelector Method for DeleteSmtpSelector

	Delete a selector mapped to a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteSmtpSelectorRequest
	*/
	DeleteSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest

	// DeleteSmtpSelectorExecute executes the request
	DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*http.Response, error)

	/*
	DeleteTeamsConfiguration Method for DeleteTeamsConfiguration

	Delete a Teams endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteTeamsConfigurationRequest
	*/
	DeleteTeamsConfiguration(ctx context.Context, uuid string) ApiDeleteTeamsConfigurationRequest

	// DeleteTeamsConfigurationExecute executes the request
	DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*http.Response, error)

	/*
	DeleteTeamsSelector Method for DeleteTeamsSelector

	Delete a selector mapped to a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteTeamsSelectorRequest
	*/
	DeleteTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest

	// DeleteTeamsSelectorExecute executes the request
	DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*http.Response, error)

	/*
	DeleteWebhookConfiguration Method for DeleteWebhookConfiguration

	Delete a Webhook endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiDeleteWebhookConfigurationRequest
	*/
	DeleteWebhookConfiguration(ctx context.Context, uuid string) ApiDeleteWebhookConfigurationRequest

	// DeleteWebhookConfigurationExecute executes the request
	DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*http.Response, error)

	/*
	DeleteWebhookSelector Method for DeleteWebhookSelector

	Delete a selector mapped to a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiDeleteWebhookSelectorRequest
	*/
	DeleteWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest

	// DeleteWebhookSelectorExecute executes the request
	DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*http.Response, error)

	/*
	GetGithubConfiguration Method for GetGithubConfiguration

	Get a GitHub endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetGithubConfigurationRequest
	*/
	GetGithubConfiguration(ctx context.Context, uuid string) ApiGetGithubConfigurationRequest

	// GetGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)

	/*
	GetGithubConfigurationStatus Method for GetGithubConfigurationStatus

	Get operational status for a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetGithubConfigurationStatusRequest
	*/
	GetGithubConfigurationStatus(ctx context.Context, uuid string) ApiGetGithubConfigurationStatusRequest

	// GetGithubConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetGithubSelector Method for GetGithubSelector

	Get a selector mapped to a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetGithubSelectorRequest
	*/
	GetGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest

	// GetGithubSelectorExecute executes the request
	//  @return NotificationSelector
	GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	GetGlobalQueryResult Method for GetGlobalQueryResult

	Get a single saved global query result

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param resultUuid
	@return ApiGetGlobalQueryResultRequest
	*/
	GetGlobalQueryResult(ctx context.Context, resultUuid string) ApiGetGlobalQueryResultRequest

	// GetGlobalQueryResultExecute executes the request
	GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*http.Response, error)

	/*
	GetIdp Method for GetIdp

	Return the configuration for a named Identity Provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiGetIdpRequest
	*/
	GetIdp(ctx context.Context, name string) ApiGetIdpRequest

	// GetIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	GetIdpExecute(r ApiGetIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)

	/*
	GetJiraConfiguration Method for GetJiraConfiguration

	Get a Jira endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetJiraConfigurationRequest
	*/
	GetJiraConfiguration(ctx context.Context, uuid string) ApiGetJiraConfigurationRequest

	// GetJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)

	/*
	GetJiraConfigurationStatus Method for GetJiraConfigurationStatus

	Get operational status for a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetJiraConfigurationStatusRequest
	*/
	GetJiraConfigurationStatus(ctx context.Context, uuid string) ApiGetJiraConfigurationStatusRequest

	// GetJiraConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetJiraSelector Method for GetJiraSelector

	Get a selector mapped to a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetJiraSelectorRequest
	*/
	GetJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest

	// GetJiraSelectorExecute executes the request
	//  @return NotificationSelector
	GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	GetOauthToken Method for GetOauthToken

	Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOauthTokenRequest
	*/
	GetOauthToken(ctx context.Context) ApiGetOauthTokenRequest

	// GetOauthTokenExecute executes the request
	//  @return TokenResponse
	GetOauthTokenExecute(r ApiGetOauthTokenRequest) (*TokenResponse, *http.Response, error)

	/*
	GetQueryResult Method for GetQueryResult

	Get a single saved query result

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param resultUuid
	@return ApiGetQueryResultRequest
	*/
	GetQueryResult(ctx context.Context, resultUuid string) ApiGetQueryResultRequest

	// GetQueryResultExecute executes the request
	GetQueryResultExecute(r ApiGetQueryResultRequest) (*http.Response, error)

	/*
	GetRole Get detailed information about a specific role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiGetRoleRequest
	*/
	GetRole(ctx context.Context, roleName string) ApiGetRoleRequest

	// GetRoleExecute executes the request
	//  @return RbacManagerRole
	GetRoleExecute(r ApiGetRoleRequest) (*RbacManagerRole, *http.Response, error)

	/*
	GetSlackConfiguration Method for GetSlackConfiguration

	Get a Slack endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSlackConfigurationRequest
	*/
	GetSlackConfiguration(ctx context.Context, uuid string) ApiGetSlackConfigurationRequest

	// GetSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)

	/*
	GetSlackConfigurationStatus Method for GetSlackConfigurationStatus

	Get operational status for a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSlackConfigurationStatusRequest
	*/
	GetSlackConfigurationStatus(ctx context.Context, uuid string) ApiGetSlackConfigurationStatusRequest

	// GetSlackConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetSlackSelector Method for GetSlackSelector

	Get a selector mapped to a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetSlackSelectorRequest
	*/
	GetSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest

	// GetSlackSelectorExecute executes the request
	//  @return NotificationSelector
	GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	GetSmtpConfiguration Method for GetSmtpConfiguration

	Get a SMTP endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSmtpConfigurationRequest
	*/
	GetSmtpConfiguration(ctx context.Context, uuid string) ApiGetSmtpConfigurationRequest

	// GetSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)

	/*
	GetSmtpConfigurationStatus Method for GetSmtpConfigurationStatus

	Get operational status for a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetSmtpConfigurationStatusRequest
	*/
	GetSmtpConfigurationStatus(ctx context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest

	// GetSmtpConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetSmtpSelector Method for GetSmtpSelector

	Get a selector mapped to a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetSmtpSelectorRequest
	*/
	GetSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest

	// GetSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	GetTeamsConfiguration Method for GetTeamsConfiguration

	Get a Teams endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetTeamsConfigurationRequest
	*/
	GetTeamsConfiguration(ctx context.Context, uuid string) ApiGetTeamsConfigurationRequest

	// GetTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)

	/*
	GetTeamsConfigurationStatus Method for GetTeamsConfigurationStatus

	Get operational status for a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetTeamsConfigurationStatusRequest
	*/
	GetTeamsConfigurationStatus(ctx context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest

	// GetTeamsConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetTeamsSelector Method for GetTeamsSelector

	Get a selector mapped to a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetTeamsSelectorRequest
	*/
	GetTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest

	// GetTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	GetWebhookConfiguration Method for GetWebhookConfiguration

	Get a Webhook endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetWebhookConfigurationRequest
	*/
	GetWebhookConfiguration(ctx context.Context, uuid string) ApiGetWebhookConfigurationRequest

	// GetWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)

	/*
	GetWebhookConfigurationStatus Method for GetWebhookConfigurationStatus

	Get operational status for a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiGetWebhookConfigurationStatusRequest
	*/
	GetWebhookConfigurationStatus(ctx context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest

	// GetWebhookConfigurationStatusExecute executes the request
	//  @return NotificationOperationalStatus
	GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error)

	/*
	GetWebhookSelector Method for GetWebhookSelector

	Get a selector mapped to a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiGetWebhookSelectorRequest
	*/
	GetWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest

	// GetWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	HealthCheck Method for HealthCheck

	Health check, returns 200 and no body if service is running

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthCheckRequest
	*/
	HealthCheck(ctx context.Context) ApiHealthCheckRequest

	// HealthCheckExecute executes the request
	HealthCheckExecute(r ApiHealthCheckRequest) (*http.Response, error)

	/*
	ListEndpoints Method for ListEndpoints

	List the system installed notification endpoints

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListEndpointsRequest
	*/
	ListEndpoints(ctx context.Context) ApiListEndpointsRequest

	// ListEndpointsExecute executes the request
	//  @return []NotificationEndpoint
	ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *http.Response, error)

	/*
	ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListFileContentSearchResultsRequest
	*/
	ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest

	// ListFileContentSearchResultsExecute executes the request
	//  @return []FileContentSearchResult
	ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error)

	/*
	ListGithubConfigurations Method for ListGithubConfigurations

	List GitHub endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListGithubConfigurationsRequest
	*/
	ListGithubConfigurations(ctx context.Context) ApiListGithubConfigurationsRequest

	// ListGithubConfigurationsExecute executes the request
	//  @return []NotificationGitHubEndpointConfigurationBase
	ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error)

	/*
	ListGithubSelectors Method for ListGithubSelectors

	List selectors mapping events for delivery to a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListGithubSelectorsRequest
	*/
	ListGithubSelectors(ctx context.Context, uuid string) ApiListGithubSelectorsRequest

	// ListGithubSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListIdps Method for ListIdps

	List the names of configured Identity Providers for this anchore installation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListIdpsRequest
	*/
	ListIdps(ctx context.Context) ApiListIdpsRequest

	// ListIdpsExecute executes the request
	//  @return []string
	ListIdpsExecute(r ApiListIdpsRequest) ([]string, *http.Response, error)

	/*
	ListJiraConfigurations Method for ListJiraConfigurations

	List Jira endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListJiraConfigurationsRequest
	*/
	ListJiraConfigurations(ctx context.Context) ApiListJiraConfigurationsRequest

	// ListJiraConfigurationsExecute executes the request
	//  @return []NotificationJiraEndpointConfigurationBase
	ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *http.Response, error)

	/*
	ListJiraSelectors Method for ListJiraSelectors

	List selectors mapping events for delivery to a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListJiraSelectorsRequest
	*/
	ListJiraSelectors(ctx context.Context, uuid string) ApiListJiraSelectorsRequest

	// ListJiraSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListRetrievedFiles Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListRetrievedFilesRequest
	*/
	ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest

	// ListRetrievedFilesExecute executes the request
	//  @return []RetrievedFile
	ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error)

	/*
	ListRoleMembers Returns a list of objects that have members in the role. The list is filtered by 'listRoleMembers' access for the 'account' element of each entry.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleName
	@return ApiListRoleMembersRequest
	*/
	ListRoleMembers(ctx context.Context, roleName string) ApiListRoleMembersRequest

	// ListRoleMembersExecute executes the request
	//  @return []RbacManagerRoleMember
	ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *http.Response, error)

	/*
	ListRoles List roles available in the system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListRolesRequest
	*/
	ListRoles(ctx context.Context) ApiListRolesRequest

	// ListRolesExecute executes the request
	//  @return []RbacManagerRoleSummary
	ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *http.Response, error)

	/*
	ListSecretSearchResults Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListSecretSearchResultsRequest
	*/
	ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest

	// ListSecretSearchResultsExecute executes the request
	//  @return []SecretSearchResult
	ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error)

	/*
	ListSelectors Method for ListSelectors

	List all selectors mapped to endpoint configurations for the account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSelectorsRequest
	*/
	ListSelectors(ctx context.Context) ApiListSelectorsRequest

	// ListSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListSlackConfigurations Method for ListSlackConfigurations

	List Slack endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSlackConfigurationsRequest
	*/
	ListSlackConfigurations(ctx context.Context) ApiListSlackConfigurationsRequest

	// ListSlackConfigurationsExecute executes the request
	//  @return []NotificationSlackEndpointConfiguration
	ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *http.Response, error)

	/*
	ListSlackSelectors Method for ListSlackSelectors

	List selectors mapping events for delivery to a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListSlackSelectorsRequest
	*/
	ListSlackSelectors(ctx context.Context, uuid string) ApiListSlackSelectorsRequest

	// ListSlackSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListSmtpConfigurations Method for ListSmtpConfigurations

	List SMTP endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSmtpConfigurationsRequest
	*/
	ListSmtpConfigurations(ctx context.Context) ApiListSmtpConfigurationsRequest

	// ListSmtpConfigurationsExecute executes the request
	//  @return []NotificationSMTPEndpointConfiguration
	ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *http.Response, error)

	/*
	ListSmtpSelectors Method for ListSmtpSelectors

	List selectors mapping events for delivery to a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListSmtpSelectorsRequest
	*/
	ListSmtpSelectors(ctx context.Context, uuid string) ApiListSmtpSelectorsRequest

	// ListSmtpSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListTeamsConfigurations Method for ListTeamsConfigurations

	List Teams endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListTeamsConfigurationsRequest
	*/
	ListTeamsConfigurations(ctx context.Context) ApiListTeamsConfigurationsRequest

	// ListTeamsConfigurationsExecute executes the request
	//  @return []NotificationTeamsEndpointConfiguration
	ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *http.Response, error)

	/*
	ListTeamsSelectors Method for ListTeamsSelectors

	List selectors mapping events for delivery to a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListTeamsSelectorsRequest
	*/
	ListTeamsSelectors(ctx context.Context, uuid string) ApiListTeamsSelectorsRequest

	// ListTeamsSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	ListUserRoles List the roles for which the requested user is a member

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param username
	@return ApiListUserRolesRequest
	*/
	ListUserRoles(ctx context.Context, username string) ApiListUserRolesRequest

	// ListUserRolesExecute executes the request
	//  @return []RbacManagerRoleMembership
	ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *http.Response, error)

	/*
	ListWebhookConfigurations Method for ListWebhookConfigurations

	List Webhook endpoint configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListWebhookConfigurationsRequest
	*/
	ListWebhookConfigurations(ctx context.Context) ApiListWebhookConfigurationsRequest

	// ListWebhookConfigurationsExecute executes the request
	//  @return []NotificationWebhookEndpointConfiguration
	ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *http.Response, error)

	/*
	ListWebhookSelectors Method for ListWebhookSelectors

	List selectors mapping events for delivery to a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiListWebhookSelectorsRequest
	*/
	ListWebhookSelectors(ctx context.Context, uuid string) ApiListWebhookSelectorsRequest

	// ListWebhookSelectorsExecute executes the request
	//  @return []NotificationSelector
	ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *http.Response, error)

	/*
	MyRoles List the roles for which the authenticated user is a member

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMyRolesRequest
	*/
	MyRoles(ctx context.Context) ApiMyRolesRequest

	// MyRolesExecute executes the request
	//  @return []RbacManagerAccountRole
	MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *http.Response, error)

	/*
	Ping Method for Ping

	Simple status check

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingRequest
	*/
	Ping(ctx context.Context) ApiPingRequest

	// PingExecute executes the request
	//  @return string
	PingExecute(r ApiPingRequest) (string, *http.Response, error)

	/*
	RevokeOauthToken Method for RevokeOauthToken

	Revoke a refresh token previously requested from /oauth/token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRevokeOauthTokenRequest
	*/
	RevokeOauthToken(ctx context.Context) ApiRevokeOauthTokenRequest

	// RevokeOauthTokenExecute executes the request
	RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*http.Response, error)

	/*
	SamlLogin Method for SamlLogin

	Initiate an SP-initiated login sequence for the Idp. The SP will respond with the SAML AuthN Request the client must send to the Idp URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idpName
	@return ApiSamlLoginRequest
	*/
	SamlLogin(ctx context.Context, idpName string) ApiSamlLoginRequest

	// SamlLoginExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlLoginExecute(r ApiSamlLoginRequest) (*RbacManagerTokenResponse, *http.Response, error)

	/*
	SamlSso Method for SamlSso

	Perform a login using a SAML assertion, no HTTP auth is required as the SAML assertion is considered the authenticating token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idpName
	@return ApiSamlSsoRequest
	*/
	SamlSso(ctx context.Context, idpName string) ApiSamlSsoRequest

	// SamlSsoExecute executes the request
	//  @return RbacManagerTokenResponse
	SamlSsoExecute(r ApiSamlSsoRequest) (*RbacManagerTokenResponse, *http.Response, error)

	/*
	TestGithubConfiguration Method for TestGithubConfiguration

	Test GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestGithubConfigurationRequest
	*/
	TestGithubConfiguration(ctx context.Context) ApiTestGithubConfigurationRequest

	// TestGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error)

	/*
	TestJiraConfiguration Method for TestJiraConfiguration

	Test Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestJiraConfigurationRequest
	*/
	TestJiraConfiguration(ctx context.Context) ApiTestJiraConfigurationRequest

	// TestJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error)

	/*
	TestSlackConfiguration Method for TestSlackConfiguration

	Test Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestSlackConfigurationRequest
	*/
	TestSlackConfiguration(ctx context.Context) ApiTestSlackConfigurationRequest

	// TestSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error)

	/*
	TestSmtpConfiguration Method for TestSmtpConfiguration

	Test SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestSmtpConfigurationRequest
	*/
	TestSmtpConfiguration(ctx context.Context) ApiTestSmtpConfigurationRequest

	// TestSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error)

	/*
	TestStoredGithubConfiguration Method for TestStoredGithubConfiguration

	Test stored GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredGithubConfigurationRequest
	*/
	TestStoredGithubConfiguration(ctx context.Context, uuid string) ApiTestStoredGithubConfigurationRequest

	// TestStoredGithubConfigurationExecute executes the request
	//  @return NotificationGitHubTestResult
	TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error)

	/*
	TestStoredJiraConfiguration Method for TestStoredJiraConfiguration

	Test stored Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredJiraConfigurationRequest
	*/
	TestStoredJiraConfiguration(ctx context.Context, uuid string) ApiTestStoredJiraConfigurationRequest

	// TestStoredJiraConfigurationExecute executes the request
	//  @return NotificationJiraTestResult
	TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error)

	/*
	TestStoredSlackConfiguration Method for TestStoredSlackConfiguration

	Test stored Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredSlackConfigurationRequest
	*/
	TestStoredSlackConfiguration(ctx context.Context, uuid string) ApiTestStoredSlackConfigurationRequest

	// TestStoredSlackConfigurationExecute executes the request
	//  @return NotificationSlackTestResult
	TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error)

	/*
	TestStoredSmtpConfiguration Method for TestStoredSmtpConfiguration

	Test stored SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredSmtpConfigurationRequest
	*/
	TestStoredSmtpConfiguration(ctx context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest

	// TestStoredSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPTestResult
	TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error)

	/*
	TestStoredTeamsConfiguration Method for TestStoredTeamsConfiguration

	Test stored Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredTeamsConfigurationRequest
	*/
	TestStoredTeamsConfiguration(ctx context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest

	// TestStoredTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error)

	/*
	TestStoredWebhookConfiguration Method for TestStoredWebhookConfiguration

	Test stored Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiTestStoredWebhookConfigurationRequest
	*/
	TestStoredWebhookConfiguration(ctx context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest

	// TestStoredWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error)

	/*
	TestTeamsConfiguration Method for TestTeamsConfiguration

	Test Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestTeamsConfigurationRequest
	*/
	TestTeamsConfiguration(ctx context.Context) ApiTestTeamsConfigurationRequest

	// TestTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsTestResult
	TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error)

	/*
	TestWebhookConfiguration Method for TestWebhookConfiguration

	Test Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestWebhookConfigurationRequest
	*/
	TestWebhookConfiguration(ctx context.Context) ApiTestWebhookConfigurationRequest

	// TestWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookTestResult
	TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error)

	/*
	UpdateEndpointStatus Method for UpdateEndpointStatus

	Update enabled status of an endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateEndpointStatusRequest
	*/
	UpdateEndpointStatus(ctx context.Context, name string) ApiUpdateEndpointStatusRequest

	// UpdateEndpointStatusExecute executes the request
	//  @return NotificationEndpointEnabledStatus
	UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (*NotificationEndpointEnabledStatus, *http.Response, error)

	/*
	UpdateGithubConfiguration Method for UpdateGithubConfiguration

	Update a GitHub endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateGithubConfigurationRequest
	*/
	UpdateGithubConfiguration(ctx context.Context, uuid string) ApiUpdateGithubConfigurationRequest

	// UpdateGithubConfigurationExecute executes the request
	//  @return NotificationGitHubEndpointConfigurationBase
	UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error)

	/*
	UpdateGithubSelector Method for UpdateGithubSelector

	Update a selector mapped to a GitHub endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateGithubSelectorRequest
	*/
	UpdateGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest

	// UpdateGithubSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	UpdateIdp Method for UpdateIdp

	Update an existing Identity Provider configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name
	@return ApiUpdateIdpRequest
	*/
	UpdateIdp(ctx context.Context, name string) ApiUpdateIdpRequest

	// UpdateIdpExecute executes the request
	//  @return RbacManagerSamlConfiguration
	UpdateIdpExecute(r ApiUpdateIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error)

	/*
	UpdateJiraConfiguration Method for UpdateJiraConfiguration

	Update a Jira endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateJiraConfigurationRequest
	*/
	UpdateJiraConfiguration(ctx context.Context, uuid string) ApiUpdateJiraConfigurationRequest

	// UpdateJiraConfigurationExecute executes the request
	//  @return NotificationJiraEndpointConfigurationBase
	UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error)

	/*
	UpdateJiraSelector Method for UpdateJiraSelector

	Update a selector mapped to a Jira endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateJiraSelectorRequest
	*/
	UpdateJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest

	// UpdateJiraSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	UpdateSlackConfiguration Method for UpdateSlackConfiguration

	Update a Slack endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateSlackConfigurationRequest
	*/
	UpdateSlackConfiguration(ctx context.Context, uuid string) ApiUpdateSlackConfigurationRequest

	// UpdateSlackConfigurationExecute executes the request
	//  @return NotificationSlackEndpointConfiguration
	UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error)

	/*
	UpdateSlackSelector Method for UpdateSlackSelector

	Update a selector mapped to a Slack endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateSlackSelectorRequest
	*/
	UpdateSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest

	// UpdateSlackSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	UpdateSmtpConfiguration Method for UpdateSmtpConfiguration

	Update a SMTP endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateSmtpConfigurationRequest
	*/
	UpdateSmtpConfiguration(ctx context.Context, uuid string) ApiUpdateSmtpConfigurationRequest

	// UpdateSmtpConfigurationExecute executes the request
	//  @return NotificationSMTPEndpointConfiguration
	UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error)

	/*
	UpdateSmtpSelector Method for UpdateSmtpSelector

	Update a selector mapped to a SMTP endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateSmtpSelectorRequest
	*/
	UpdateSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest

	// UpdateSmtpSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	UpdateTeamsConfiguration Method for UpdateTeamsConfiguration

	Update a Teams endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateTeamsConfigurationRequest
	*/
	UpdateTeamsConfiguration(ctx context.Context, uuid string) ApiUpdateTeamsConfigurationRequest

	// UpdateTeamsConfigurationExecute executes the request
	//  @return NotificationTeamsEndpointConfiguration
	UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error)

	/*
	UpdateTeamsSelector Method for UpdateTeamsSelector

	Update a selector mapped to a Teams endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateTeamsSelectorRequest
	*/
	UpdateTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest

	// UpdateTeamsSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	UpdateWebhookConfiguration Method for UpdateWebhookConfiguration

	Update a Webhook endpoint configuration by it's UUID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid
	@return ApiUpdateWebhookConfigurationRequest
	*/
	UpdateWebhookConfiguration(ctx context.Context, uuid string) ApiUpdateWebhookConfigurationRequest

	// UpdateWebhookConfigurationExecute executes the request
	//  @return NotificationWebhookEndpointConfiguration
	UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error)

	/*
	UpdateWebhookSelector Method for UpdateWebhookSelector

	Update a selector mapped to a Webhook endpoint configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param configurationUuid
	@param selectorUuid
	@return ApiUpdateWebhookSelectorRequest
	*/
	UpdateWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest

	// UpdateWebhookSelectorExecute executes the request
	//  @return NotificationSelector
	UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (*NotificationSelector, *http.Response, error)

	/*
	VersionCheck Method for VersionCheck

	Returns the version object for the service, including db schema version info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVersionCheckRequest
	*/
	VersionCheck(ctx context.Context) ApiVersionCheckRequest

	// VersionCheckExecute executes the request
	//  @return ServiceVersion
	VersionCheckExecute(r ApiVersionCheckRequest) (*ServiceVersion, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAddGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationGitHubEndpointConfigurationPost
}

func (r ApiAddGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPost) ApiAddGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.AddGithubConfigurationExecute(r)
}

/*
AddGithubConfiguration Method for AddGithubConfiguration

Create a new GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddGithubConfigurationRequest
*/
func (a *DefaultApiService) AddGithubConfiguration(ctx context.Context) ApiAddGithubConfigurationRequest {
	return ApiAddGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
func (a *DefaultApiService) AddGithubConfigurationExecute(r ApiAddGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddGithubConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddGithubSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddGithubSelectorRequest) Selector(selector NotificationSelector) ApiAddGithubSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddGithubSelectorExecute(r)
}

/*
AddGithubSelector Method for AddGithubSelector

Add selector for mapping events for delivery to a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddGithubSelectorRequest
*/
func (a *DefaultApiService) AddGithubSelector(ctx context.Context, uuid string) ApiAddGithubSelectorRequest {
	return ApiAddGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddGithubSelectorExecute(r ApiAddGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddGithubSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddIdpRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *RbacManagerSamlConfiguration
}

func (r ApiAddIdpRequest) Configuration(configuration RbacManagerSamlConfiguration) ApiAddIdpRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
	return r.ApiService.AddIdpExecute(r)
}

/*
AddIdp Method for AddIdp

Add a new Identity Provider to the system, with a specific name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddIdpRequest
*/
func (a *DefaultApiService) AddIdp(ctx context.Context) ApiAddIdpRequest {
	return ApiAddIdpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
func (a *DefaultApiService) AddIdpExecute(r ApiAddIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddIdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationJiraEndpointConfigurationPost
}

func (r ApiAddJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPost) ApiAddJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.AddJiraConfigurationExecute(r)
}

/*
AddJiraConfiguration Method for AddJiraConfiguration

Create a new Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddJiraConfigurationRequest
*/
func (a *DefaultApiService) AddJiraConfiguration(ctx context.Context) ApiAddJiraConfigurationRequest {
	return ApiAddJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
func (a *DefaultApiService) AddJiraConfigurationExecute(r ApiAddJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddJiraConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddJiraSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddJiraSelectorRequest) Selector(selector NotificationSelector) ApiAddJiraSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddJiraSelectorExecute(r)
}

/*
AddJiraSelector Method for AddJiraSelector

Add selector for mapping events for delivery to a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddJiraSelectorRequest
*/
func (a *DefaultApiService) AddJiraSelector(ctx context.Context, uuid string) ApiAddJiraSelectorRequest {
	return ApiAddJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddJiraSelectorExecute(r ApiAddJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddJiraSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddRoleUserRequest struct {
	ctx context.Context
	ApiService DefaultApi
	roleName string
	member *RbacManagerRoleMember
}

func (r ApiAddRoleUserRequest) Member(member RbacManagerRoleMember) ApiAddRoleUserRequest {
	r.member = &member
	return r
}

func (r ApiAddRoleUserRequest) Execute() (*RbacManagerRoleMember, *http.Response, error) {
	return r.ApiService.AddRoleUserExecute(r)
}

/*
AddRoleUser Add a user to the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiAddRoleUserRequest
*/
func (a *DefaultApiService) AddRoleUser(ctx context.Context, roleName string) ApiAddRoleUserRequest {
	return ApiAddRoleUserRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RbacManagerRoleMember
func (a *DefaultApiService) AddRoleUserExecute(r ApiAddRoleUserRequest) (*RbacManagerRoleMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerRoleMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddRoleUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.member == nil {
		return localVarReturnValue, nil, reportError("member is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.member
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiAddSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiAddSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	return r.ApiService.AddSlackConfigurationExecute(r)
}

/*
AddSlackConfiguration Method for AddSlackConfiguration

Create a new Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSlackConfigurationRequest
*/
func (a *DefaultApiService) AddSlackConfiguration(ctx context.Context) ApiAddSlackConfigurationRequest {
	return ApiAddSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
func (a *DefaultApiService) AddSlackConfigurationExecute(r ApiAddSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSlackConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSlackSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddSlackSelectorRequest) Selector(selector NotificationSelector) ApiAddSlackSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddSlackSelectorExecute(r)
}

/*
AddSlackSelector Method for AddSlackSelector

Add selector for mapping events for delivery to a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSlackSelectorRequest
*/
func (a *DefaultApiService) AddSlackSelector(ctx context.Context, uuid string) ApiAddSlackSelectorRequest {
	return ApiAddSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddSlackSelectorExecute(r ApiAddSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSlackSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiAddSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiAddSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	return r.ApiService.AddSmtpConfigurationExecute(r)
}

/*
AddSmtpConfiguration Method for AddSmtpConfiguration

Create a new SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSmtpConfigurationRequest
*/
func (a *DefaultApiService) AddSmtpConfiguration(ctx context.Context) ApiAddSmtpConfigurationRequest {
	return ApiAddSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
func (a *DefaultApiService) AddSmtpConfigurationExecute(r ApiAddSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSmtpConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddSmtpSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddSmtpSelectorRequest) Selector(selector NotificationSelector) ApiAddSmtpSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddSmtpSelectorExecute(r)
}

/*
AddSmtpSelector Method for AddSmtpSelector

Add selector for mapping events for delivery to a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddSmtpSelectorRequest
*/
func (a *DefaultApiService) AddSmtpSelector(ctx context.Context, uuid string) ApiAddSmtpSelectorRequest {
	return ApiAddSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddSmtpSelectorExecute(r ApiAddSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSmtpSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiAddTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiAddTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	return r.ApiService.AddTeamsConfigurationExecute(r)
}

/*
AddTeamsConfiguration Method for AddTeamsConfiguration

Create a new Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddTeamsConfigurationRequest
*/
func (a *DefaultApiService) AddTeamsConfiguration(ctx context.Context) ApiAddTeamsConfigurationRequest {
	return ApiAddTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
func (a *DefaultApiService) AddTeamsConfigurationExecute(r ApiAddTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddTeamsConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTeamsSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddTeamsSelectorRequest) Selector(selector NotificationSelector) ApiAddTeamsSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddTeamsSelectorExecute(r)
}

/*
AddTeamsSelector Method for AddTeamsSelector

Add selector for mapping events for delivery to a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddTeamsSelectorRequest
*/
func (a *DefaultApiService) AddTeamsSelector(ctx context.Context, uuid string) ApiAddTeamsSelectorRequest {
	return ApiAddTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddTeamsSelectorExecute(r ApiAddTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddTeamsSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiAddWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiAddWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiAddWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	return r.ApiService.AddWebhookConfigurationExecute(r)
}

/*
AddWebhookConfiguration Method for AddWebhookConfiguration

Create a new Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddWebhookConfigurationRequest
*/
func (a *DefaultApiService) AddWebhookConfiguration(ctx context.Context) ApiAddWebhookConfigurationRequest {
	return ApiAddWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
func (a *DefaultApiService) AddWebhookConfigurationExecute(r ApiAddWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddWebhookConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddWebhookSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	selector *NotificationSelector
}

func (r ApiAddWebhookSelectorRequest) Selector(selector NotificationSelector) ApiAddWebhookSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiAddWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.AddWebhookSelectorExecute(r)
}

/*
AddWebhookSelector Method for AddWebhookSelector

Add selector for mapping events for delivery to a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiAddWebhookSelectorRequest
*/
func (a *DefaultApiService) AddWebhookSelector(ctx context.Context, uuid string) ApiAddWebhookSelectorRequest {
	return ApiAddWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) AddWebhookSelectorExecute(r ApiAddWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddWebhookSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteGithubConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGithubConfigurationExecute(r)
}

/*
DeleteGithubConfiguration Method for DeleteGithubConfiguration

Delete a GitHub endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteGithubConfigurationRequest
*/
func (a *DefaultApiService) DeleteGithubConfiguration(ctx context.Context, uuid string) ApiDeleteGithubConfigurationRequest {
	return ApiDeleteGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteGithubConfigurationExecute(r ApiDeleteGithubConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteGithubConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGithubSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteGithubSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGithubSelectorExecute(r)
}

/*
DeleteGithubSelector Method for DeleteGithubSelector

Delete a selector mapped to a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteGithubSelectorRequest
*/
func (a *DefaultApiService) DeleteGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteGithubSelectorRequest {
	return ApiDeleteGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteGithubSelectorExecute(r ApiDeleteGithubSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteGithubSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteIdpRequest struct {
	ctx context.Context
	ApiService DefaultApi
	name string
}

func (r ApiDeleteIdpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIdpExecute(r)
}

/*
DeleteIdp Method for DeleteIdp

Delete an idp configuration. Users will not longer be able to login from this idp. In addition, any users that have been configured explicitly or JIT Provisioned on this IDP will be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiDeleteIdpRequest
*/
func (a *DefaultApiService) DeleteIdp(ctx context.Context, name string) ApiDeleteIdpRequest {
	return ApiDeleteIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteIdpExecute(r ApiDeleteIdpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIdp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteJiraConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJiraConfigurationExecute(r)
}

/*
DeleteJiraConfiguration Method for DeleteJiraConfiguration

Delete a Jira endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteJiraConfigurationRequest
*/
func (a *DefaultApiService) DeleteJiraConfiguration(ctx context.Context, uuid string) ApiDeleteJiraConfigurationRequest {
	return ApiDeleteJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteJiraConfigurationExecute(r ApiDeleteJiraConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteJiraConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteJiraSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteJiraSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteJiraSelectorExecute(r)
}

/*
DeleteJiraSelector Method for DeleteJiraSelector

Delete a selector mapped to a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteJiraSelectorRequest
*/
func (a *DefaultApiService) DeleteJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteJiraSelectorRequest {
	return ApiDeleteJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteJiraSelectorExecute(r ApiDeleteJiraSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteJiraSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRoleUserRequest struct {
	ctx context.Context
	ApiService DefaultApi
	roleName string
	username *string
	forAccount *string
}

// The username to remove the role for
func (r ApiDeleteRoleUserRequest) Username(username string) ApiDeleteRoleUserRequest {
	r.username = &username
	return r
}

// The account that the user has the role to be removed
func (r ApiDeleteRoleUserRequest) ForAccount(forAccount string) ApiDeleteRoleUserRequest {
	r.forAccount = &forAccount
	return r
}

func (r ApiDeleteRoleUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleUserExecute(r)
}

/*
DeleteRoleUser Remove a user from the role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiDeleteRoleUserRequest
*/
func (a *DefaultApiService) DeleteRoleUser(ctx context.Context, roleName string) ApiDeleteRoleUserRequest {
	return ApiDeleteRoleUserRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteRoleUserExecute(r ApiDeleteRoleUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteRoleUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.username == nil {
		return nil, reportError("username is required and must be specified")
	}
	if r.forAccount == nil {
		return nil, reportError("forAccount is required and must be specified")
	}

	localVarQueryParams.Add("username", parameterToString(*r.username, ""))
	localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteSlackConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSlackConfigurationExecute(r)
}

/*
DeleteSlackConfiguration Method for DeleteSlackConfiguration

Delete a Slack endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSlackConfigurationRequest
*/
func (a *DefaultApiService) DeleteSlackConfiguration(ctx context.Context, uuid string) ApiDeleteSlackConfigurationRequest {
	return ApiDeleteSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSlackConfigurationExecute(r ApiDeleteSlackConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSlackConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteSlackSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSlackSelectorExecute(r)
}

/*
DeleteSlackSelector Method for DeleteSlackSelector

Delete a selector mapped to a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteSlackSelectorRequest
*/
func (a *DefaultApiService) DeleteSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSlackSelectorRequest {
	return ApiDeleteSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSlackSelectorExecute(r ApiDeleteSlackSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSlackSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteSmtpConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSmtpConfigurationExecute(r)
}

/*
DeleteSmtpConfiguration Method for DeleteSmtpConfiguration

Delete a SMTP endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteSmtpConfigurationRequest
*/
func (a *DefaultApiService) DeleteSmtpConfiguration(ctx context.Context, uuid string) ApiDeleteSmtpConfigurationRequest {
	return ApiDeleteSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSmtpConfigurationExecute(r ApiDeleteSmtpConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSmtpConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSmtpSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteSmtpSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSmtpSelectorExecute(r)
}

/*
DeleteSmtpSelector Method for DeleteSmtpSelector

Delete a selector mapped to a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteSmtpSelectorRequest
*/
func (a *DefaultApiService) DeleteSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteSmtpSelectorRequest {
	return ApiDeleteSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSmtpSelectorExecute(r ApiDeleteSmtpSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSmtpSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteTeamsConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTeamsConfigurationExecute(r)
}

/*
DeleteTeamsConfiguration Method for DeleteTeamsConfiguration

Delete a Teams endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteTeamsConfigurationRequest
*/
func (a *DefaultApiService) DeleteTeamsConfiguration(ctx context.Context, uuid string) ApiDeleteTeamsConfigurationRequest {
	return ApiDeleteTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTeamsConfigurationExecute(r ApiDeleteTeamsConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTeamsConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeamsSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteTeamsSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTeamsSelectorExecute(r)
}

/*
DeleteTeamsSelector Method for DeleteTeamsSelector

Delete a selector mapped to a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteTeamsSelectorRequest
*/
func (a *DefaultApiService) DeleteTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteTeamsSelectorRequest {
	return ApiDeleteTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTeamsSelectorExecute(r ApiDeleteTeamsSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTeamsSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiDeleteWebhookConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWebhookConfigurationExecute(r)
}

/*
DeleteWebhookConfiguration Method for DeleteWebhookConfiguration

Delete a Webhook endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiDeleteWebhookConfigurationRequest
*/
func (a *DefaultApiService) DeleteWebhookConfiguration(ctx context.Context, uuid string) ApiDeleteWebhookConfigurationRequest {
	return ApiDeleteWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteWebhookConfigurationExecute(r ApiDeleteWebhookConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteWebhookConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiDeleteWebhookSelectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWebhookSelectorExecute(r)
}

/*
DeleteWebhookSelector Method for DeleteWebhookSelector

Delete a selector mapped to a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiDeleteWebhookSelectorRequest
*/
func (a *DefaultApiService) DeleteWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiDeleteWebhookSelectorRequest {
	return ApiDeleteWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteWebhookSelectorExecute(r ApiDeleteWebhookSelectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteWebhookSelector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.GetGithubConfigurationExecute(r)
}

/*
GetGithubConfiguration Method for GetGithubConfiguration

Get a GitHub endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationRequest
*/
func (a *DefaultApiService) GetGithubConfiguration(ctx context.Context, uuid string) ApiGetGithubConfigurationRequest {
	return ApiGetGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
func (a *DefaultApiService) GetGithubConfigurationExecute(r ApiGetGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetGithubConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetGithubConfigurationStatusExecute(r)
}

/*
GetGithubConfigurationStatus Method for GetGithubConfigurationStatus

Get operational status for a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetGithubConfigurationStatusRequest
*/
func (a *DefaultApiService) GetGithubConfigurationStatus(ctx context.Context, uuid string) ApiGetGithubConfigurationStatusRequest {
	return ApiGetGithubConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetGithubConfigurationStatusExecute(r ApiGetGithubConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGithubSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetGithubSelectorExecute(r)
}

/*
GetGithubSelector Method for GetGithubSelector

Get a selector mapped to a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetGithubSelectorRequest
*/
func (a *DefaultApiService) GetGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetGithubSelectorRequest {
	return ApiGetGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetGithubSelectorExecute(r ApiGetGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGithubSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalQueryResultRequest struct {
	ctx context.Context
	ApiService DefaultApi
	resultUuid string
	page *int32
}

// Page number to fetch. If omitted, &#39;1&#39; is default. Page numbers start at 1
func (r ApiGetGlobalQueryResultRequest) Page(page int32) ApiGetGlobalQueryResultRequest {
	r.page = &page
	return r
}

func (r ApiGetGlobalQueryResultRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGlobalQueryResultExecute(r)
}

/*
GetGlobalQueryResult Method for GetGlobalQueryResult

Get a single saved global query result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetGlobalQueryResultRequest
*/
func (a *DefaultApiService) GetGlobalQueryResult(ctx context.Context, resultUuid string) ApiGetGlobalQueryResultRequest {
	return ApiGetGlobalQueryResultRequest{
		ApiService: a,
		ctx: ctx,
		resultUuid: resultUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetGlobalQueryResultExecute(r ApiGetGlobalQueryResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetGlobalQueryResult")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/reports/global/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", url.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetIdpRequest struct {
	ctx context.Context
	ApiService DefaultApi
	name string
}

func (r ApiGetIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
	return r.ApiService.GetIdpExecute(r)
}

/*
GetIdp Method for GetIdp

Return the configuration for a named Identity Provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiGetIdpRequest
*/
func (a *DefaultApiService) GetIdp(ctx context.Context, name string) ApiGetIdpRequest {
	return ApiGetIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
func (a *DefaultApiService) GetIdpExecute(r ApiGetIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.GetJiraConfigurationExecute(r)
}

/*
GetJiraConfiguration Method for GetJiraConfiguration

Get a Jira endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationRequest
*/
func (a *DefaultApiService) GetJiraConfiguration(ctx context.Context, uuid string) ApiGetJiraConfigurationRequest {
	return ApiGetJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
func (a *DefaultApiService) GetJiraConfigurationExecute(r ApiGetJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetJiraConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetJiraConfigurationStatusExecute(r)
}

/*
GetJiraConfigurationStatus Method for GetJiraConfigurationStatus

Get operational status for a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetJiraConfigurationStatusRequest
*/
func (a *DefaultApiService) GetJiraConfigurationStatus(ctx context.Context, uuid string) ApiGetJiraConfigurationStatusRequest {
	return ApiGetJiraConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetJiraConfigurationStatusExecute(r ApiGetJiraConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJiraSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetJiraSelectorExecute(r)
}

/*
GetJiraSelector Method for GetJiraSelector

Get a selector mapped to a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetJiraSelectorRequest
*/
func (a *DefaultApiService) GetJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetJiraSelectorRequest {
	return ApiGetJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetJiraSelectorExecute(r ApiGetJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJiraSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOauthTokenRequest struct {
	ctx context.Context
	ApiService DefaultApi
	grantType *string
	username *string
	password *string
	clientId *string
	refreshToken *string
}

// OAuth Grant type for token
func (r ApiGetOauthTokenRequest) GrantType(grantType string) ApiGetOauthTokenRequest {
	r.grantType = &grantType
	return r
}

// User to assign OAuth token to
func (r ApiGetOauthTokenRequest) Username(username string) ApiGetOauthTokenRequest {
	r.username = &username
	return r
}

// Password for corresponding user
func (r ApiGetOauthTokenRequest) Password(password string) ApiGetOauthTokenRequest {
	r.password = &password
	return r
}

// The type of client used for the OAuth token
func (r ApiGetOauthTokenRequest) ClientId(clientId string) ApiGetOauthTokenRequest {
	r.clientId = &clientId
	return r
}

// The refresh token from a previous password grant request, used to get a new access_token
func (r ApiGetOauthTokenRequest) RefreshToken(refreshToken string) ApiGetOauthTokenRequest {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiGetOauthTokenRequest) Execute() (*TokenResponse, *http.Response, error) {
	return r.ApiService.GetOauthTokenExecute(r)
}

/*
GetOauthToken Method for GetOauthToken

Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOauthTokenRequest
*/
func (a *DefaultApiService) GetOauthToken(ctx context.Context) ApiGetOauthTokenRequest {
	return ApiGetOauthTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenResponse
func (a *DefaultApiService) GetOauthTokenExecute(r ApiGetOauthTokenRequest) (*TokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetOauthToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.grantType != nil {
		localVarFormParams.Add("grant_type", parameterToString(*r.grantType, ""))
	}
	if r.username != nil {
		localVarFormParams.Add("username", parameterToString(*r.username, ""))
	}
	if r.password != nil {
		localVarFormParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.clientId != nil {
		localVarFormParams.Add("client_id", parameterToString(*r.clientId, ""))
	}
	if r.refreshToken != nil {
		localVarFormParams.Add("refresh_token", parameterToString(*r.refreshToken, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryResultRequest struct {
	ctx context.Context
	ApiService DefaultApi
	resultUuid string
	page *int32
}

// Page number to fetch. If omitted, &#39;1&#39; is default. Page numbers start at 1
func (r ApiGetQueryResultRequest) Page(page int32) ApiGetQueryResultRequest {
	r.page = &page
	return r
}

func (r ApiGetQueryResultRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetQueryResultExecute(r)
}

/*
GetQueryResult Method for GetQueryResult

Get a single saved query result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resultUuid
 @return ApiGetQueryResultRequest
*/
func (a *DefaultApiService) GetQueryResult(ctx context.Context, resultUuid string) ApiGetQueryResultRequest {
	return ApiGetQueryResultRequest{
		ApiService: a,
		ctx: ctx,
		resultUuid: resultUuid,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetQueryResultExecute(r ApiGetQueryResultRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetQueryResult")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reporting/scheduled-query-results/{result_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"result_uuid"+"}", url.PathEscape(parameterToString(r.resultUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRoleRequest struct {
	ctx context.Context
	ApiService DefaultApi
	roleName string
}

func (r ApiGetRoleRequest) Execute() (*RbacManagerRole, *http.Response, error) {
	return r.ApiService.GetRoleExecute(r)
}

/*
GetRole Get detailed information about a specific role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiGetRoleRequest
*/
func (a *DefaultApiService) GetRole(ctx context.Context, roleName string) ApiGetRoleRequest {
	return ApiGetRoleRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return RbacManagerRole
func (a *DefaultApiService) GetRoleExecute(r ApiGetRoleRequest) (*RbacManagerRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	return r.ApiService.GetSlackConfigurationExecute(r)
}

/*
GetSlackConfiguration Method for GetSlackConfiguration

Get a Slack endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationRequest
*/
func (a *DefaultApiService) GetSlackConfiguration(ctx context.Context, uuid string) ApiGetSlackConfigurationRequest {
	return ApiGetSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
func (a *DefaultApiService) GetSlackConfigurationExecute(r ApiGetSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetSlackConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetSlackConfigurationStatusExecute(r)
}

/*
GetSlackConfigurationStatus Method for GetSlackConfigurationStatus

Get operational status for a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSlackConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSlackConfigurationStatus(ctx context.Context, uuid string) ApiGetSlackConfigurationStatusRequest {
	return ApiGetSlackConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetSlackConfigurationStatusExecute(r ApiGetSlackConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetSlackSelectorExecute(r)
}

/*
GetSlackSelector Method for GetSlackSelector

Get a selector mapped to a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetSlackSelectorRequest
*/
func (a *DefaultApiService) GetSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSlackSelectorRequest {
	return ApiGetSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetSlackSelectorExecute(r ApiGetSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSlackSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	return r.ApiService.GetSmtpConfigurationExecute(r)
}

/*
GetSmtpConfiguration Method for GetSmtpConfiguration

Get a SMTP endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationRequest
*/
func (a *DefaultApiService) GetSmtpConfiguration(ctx context.Context, uuid string) ApiGetSmtpConfigurationRequest {
	return ApiGetSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
func (a *DefaultApiService) GetSmtpConfigurationExecute(r ApiGetSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetSmtpConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetSmtpConfigurationStatusExecute(r)
}

/*
GetSmtpConfigurationStatus Method for GetSmtpConfigurationStatus

Get operational status for a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetSmtpConfigurationStatusRequest
*/
func (a *DefaultApiService) GetSmtpConfigurationStatus(ctx context.Context, uuid string) ApiGetSmtpConfigurationStatusRequest {
	return ApiGetSmtpConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetSmtpConfigurationStatusExecute(r ApiGetSmtpConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSmtpSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetSmtpSelectorExecute(r)
}

/*
GetSmtpSelector Method for GetSmtpSelector

Get a selector mapped to a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetSmtpSelectorRequest
*/
func (a *DefaultApiService) GetSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetSmtpSelectorRequest {
	return ApiGetSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetSmtpSelectorExecute(r ApiGetSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmtpSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	return r.ApiService.GetTeamsConfigurationExecute(r)
}

/*
GetTeamsConfiguration Method for GetTeamsConfiguration

Get a Teams endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationRequest
*/
func (a *DefaultApiService) GetTeamsConfiguration(ctx context.Context, uuid string) ApiGetTeamsConfigurationRequest {
	return ApiGetTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
func (a *DefaultApiService) GetTeamsConfigurationExecute(r ApiGetTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetTeamsConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetTeamsConfigurationStatusExecute(r)
}

/*
GetTeamsConfigurationStatus Method for GetTeamsConfigurationStatus

Get operational status for a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetTeamsConfigurationStatusRequest
*/
func (a *DefaultApiService) GetTeamsConfigurationStatus(ctx context.Context, uuid string) ApiGetTeamsConfigurationStatusRequest {
	return ApiGetTeamsConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetTeamsConfigurationStatusExecute(r ApiGetTeamsConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetTeamsSelectorExecute(r)
}

/*
GetTeamsSelector Method for GetTeamsSelector

Get a selector mapped to a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetTeamsSelectorRequest
*/
func (a *DefaultApiService) GetTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetTeamsSelectorRequest {
	return ApiGetTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetTeamsSelectorExecute(r ApiGetTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTeamsSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	return r.ApiService.GetWebhookConfigurationExecute(r)
}

/*
GetWebhookConfiguration Method for GetWebhookConfiguration

Get a Webhook endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationRequest
*/
func (a *DefaultApiService) GetWebhookConfiguration(ctx context.Context, uuid string) ApiGetWebhookConfigurationRequest {
	return ApiGetWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
func (a *DefaultApiService) GetWebhookConfigurationExecute(r ApiGetWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookConfigurationStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiGetWebhookConfigurationStatusRequest) Execute() (*NotificationOperationalStatus, *http.Response, error) {
	return r.ApiService.GetWebhookConfigurationStatusExecute(r)
}

/*
GetWebhookConfigurationStatus Method for GetWebhookConfigurationStatus

Get operational status for a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiGetWebhookConfigurationStatusRequest
*/
func (a *DefaultApiService) GetWebhookConfigurationStatus(ctx context.Context, uuid string) ApiGetWebhookConfigurationStatusRequest {
	return ApiGetWebhookConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationOperationalStatus
func (a *DefaultApiService) GetWebhookConfigurationStatusExecute(r ApiGetWebhookConfigurationStatusRequest) (*NotificationOperationalStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationOperationalStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
}

func (r ApiGetWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.GetWebhookSelectorExecute(r)
}

/*
GetWebhookSelector Method for GetWebhookSelector

Get a selector mapped to a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiGetWebhookSelectorRequest
*/
func (a *DefaultApiService) GetWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiGetWebhookSelectorRequest {
	return ApiGetWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) GetWebhookSelectorExecute(r ApiGetWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetWebhookSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthCheckRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiHealthCheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.HealthCheckExecute(r)
}

/*
HealthCheck Method for HealthCheck

Health check, returns 200 and no body if service is running

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthCheckRequest
*/
func (a *DefaultApiService) HealthCheck(ctx context.Context) ApiHealthCheckRequest {
	return ApiHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) HealthCheckExecute(r ApiHealthCheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HealthCheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListEndpointsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListEndpointsRequest) Execute() ([]NotificationEndpoint, *http.Response, error) {
	return r.ApiService.ListEndpointsExecute(r)
}

/*
ListEndpoints Method for ListEndpoints

List the system installed notification endpoints

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListEndpointsRequest
*/
func (a *DefaultApiService) ListEndpoints(ctx context.Context) ApiListEndpointsRequest {
	return ApiListEndpointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationEndpoint
func (a *DefaultApiService) ListEndpointsExecute(r ApiListEndpointsRequest) ([]NotificationEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListEndpoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFileContentSearchResultsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	imageDigest string
}

func (r ApiListFileContentSearchResultsRequest) Execute() ([]FileContentSearchResult, *http.Response, error) {
	return r.ApiService.ListFileContentSearchResultsExecute(r)
}

/*
ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListFileContentSearchResultsRequest
*/
func (a *DefaultApiService) ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest {
	return ApiListFileContentSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []FileContentSearchResult
func (a *DefaultApiService) ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileContentSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListFileContentSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/file-content-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGithubConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListGithubConfigurationsRequest) Execute() ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.ListGithubConfigurationsExecute(r)
}

/*
ListGithubConfigurations Method for ListGithubConfigurations

List GitHub endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGithubConfigurationsRequest
*/
func (a *DefaultApiService) ListGithubConfigurations(ctx context.Context) ApiListGithubConfigurationsRequest {
	return ApiListGithubConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationGitHubEndpointConfigurationBase
func (a *DefaultApiService) ListGithubConfigurationsExecute(r ApiListGithubConfigurationsRequest) ([]NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationGitHubEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListGithubConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGithubSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListGithubSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListGithubSelectorsExecute(r)
}

/*
ListGithubSelectors Method for ListGithubSelectors

List selectors mapping events for delivery to a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListGithubSelectorsRequest
*/
func (a *DefaultApiService) ListGithubSelectors(ctx context.Context, uuid string) ApiListGithubSelectorsRequest {
	return ApiListGithubSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListGithubSelectorsExecute(r ApiListGithubSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListGithubSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIdpsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListIdpsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ListIdpsExecute(r)
}

/*
ListIdps Method for ListIdps

List the names of configured Identity Providers for this anchore installation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdpsRequest
*/
func (a *DefaultApiService) ListIdps(ctx context.Context) ApiListIdpsRequest {
	return ApiListIdpsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []string
func (a *DefaultApiService) ListIdpsExecute(r ApiListIdpsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListIdps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJiraConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListJiraConfigurationsRequest) Execute() ([]NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.ListJiraConfigurationsExecute(r)
}

/*
ListJiraConfigurations Method for ListJiraConfigurations

List Jira endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListJiraConfigurationsRequest
*/
func (a *DefaultApiService) ListJiraConfigurations(ctx context.Context) ApiListJiraConfigurationsRequest {
	return ApiListJiraConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationJiraEndpointConfigurationBase
func (a *DefaultApiService) ListJiraConfigurationsExecute(r ApiListJiraConfigurationsRequest) ([]NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationJiraEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListJiraConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJiraSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListJiraSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListJiraSelectorsExecute(r)
}

/*
ListJiraSelectors Method for ListJiraSelectors

List selectors mapping events for delivery to a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListJiraSelectorsRequest
*/
func (a *DefaultApiService) ListJiraSelectors(ctx context.Context, uuid string) ApiListJiraSelectorsRequest {
	return ApiListJiraSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListJiraSelectorsExecute(r ApiListJiraSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListJiraSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRetrievedFilesRequest struct {
	ctx context.Context
	ApiService DefaultApi
	imageDigest string
}

func (r ApiListRetrievedFilesRequest) Execute() ([]RetrievedFile, *http.Response, error) {
	return r.ApiService.ListRetrievedFilesExecute(r)
}

/*
ListRetrievedFiles Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListRetrievedFilesRequest
*/
func (a *DefaultApiService) ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest {
	return ApiListRetrievedFilesRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []RetrievedFile
func (a *DefaultApiService) ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RetrievedFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRetrievedFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/retrieved-files"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRoleMembersRequest struct {
	ctx context.Context
	ApiService DefaultApi
	roleName string
	forAccount *string
}

// Optional filter parameter to limit the set fo returned items to only those with matching account. Will return Access Denied if caller does not have permission to listRoleMembers for that account.
func (r ApiListRoleMembersRequest) ForAccount(forAccount string) ApiListRoleMembersRequest {
	r.forAccount = &forAccount
	return r
}

func (r ApiListRoleMembersRequest) Execute() ([]RbacManagerRoleMember, *http.Response, error) {
	return r.ApiService.ListRoleMembersExecute(r)
}

/*
ListRoleMembers Returns a list of objects that have members in the role. The list is filtered by 'listRoleMembers' access for the 'account' element of each entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleName
 @return ApiListRoleMembersRequest
*/
func (a *DefaultApiService) ListRoleMembers(ctx context.Context, roleName string) ApiListRoleMembersRequest {
	return ApiListRoleMembersRequest{
		ApiService: a,
		ctx: ctx,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleMember
func (a *DefaultApiService) ListRoleMembersExecute(r ApiListRoleMembersRequest) ([]RbacManagerRoleMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RbacManagerRoleMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoleMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles/{role_name}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterToString(r.roleName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forAccount != nil {
		localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRolesRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListRolesRequest) Execute() ([]RbacManagerRoleSummary, *http.Response, error) {
	return r.ApiService.ListRolesExecute(r)
}

/*
ListRoles List roles available in the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRolesRequest
*/
func (a *DefaultApiService) ListRoles(ctx context.Context) ApiListRolesRequest {
	return ApiListRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleSummary
func (a *DefaultApiService) ListRolesExecute(r ApiListRolesRequest) ([]RbacManagerRoleSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RbacManagerRoleSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSecretSearchResultsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	imageDigest string
}

func (r ApiListSecretSearchResultsRequest) Execute() ([]SecretSearchResult, *http.Response, error) {
	return r.ApiService.ListSecretSearchResultsExecute(r)
}

/*
ListSecretSearchResults Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListSecretSearchResultsRequest
*/
func (a *DefaultApiService) ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest {
	return ApiListSecretSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []SecretSearchResult
func (a *DefaultApiService) ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SecretSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSecretSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/secret-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterToString(r.imageDigest, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListSelectorsExecute(r)
}

/*
ListSelectors Method for ListSelectors

List all selectors mapped to endpoint configurations for the account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSelectorsRequest
*/
func (a *DefaultApiService) ListSelectors(ctx context.Context) ApiListSelectorsRequest {
	return ApiListSelectorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListSelectorsExecute(r ApiListSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/selectors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSlackConfigurationsRequest) Execute() ([]NotificationSlackEndpointConfiguration, *http.Response, error) {
	return r.ApiService.ListSlackConfigurationsExecute(r)
}

/*
ListSlackConfigurations Method for ListSlackConfigurations

List Slack endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSlackConfigurationsRequest
*/
func (a *DefaultApiService) ListSlackConfigurations(ctx context.Context) ApiListSlackConfigurationsRequest {
	return ApiListSlackConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSlackEndpointConfiguration
func (a *DefaultApiService) ListSlackConfigurationsExecute(r ApiListSlackConfigurationsRequest) ([]NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSlackEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSlackConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListSlackSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListSlackSelectorsExecute(r)
}

/*
ListSlackSelectors Method for ListSlackSelectors

List selectors mapping events for delivery to a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSlackSelectorsRequest
*/
func (a *DefaultApiService) ListSlackSelectors(ctx context.Context, uuid string) ApiListSlackSelectorsRequest {
	return ApiListSlackSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListSlackSelectorsExecute(r ApiListSlackSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSlackSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSmtpConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListSmtpConfigurationsRequest) Execute() ([]NotificationSMTPEndpointConfiguration, *http.Response, error) {
	return r.ApiService.ListSmtpConfigurationsExecute(r)
}

/*
ListSmtpConfigurations Method for ListSmtpConfigurations

List SMTP endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSmtpConfigurationsRequest
*/
func (a *DefaultApiService) ListSmtpConfigurations(ctx context.Context) ApiListSmtpConfigurationsRequest {
	return ApiListSmtpConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationSMTPEndpointConfiguration
func (a *DefaultApiService) ListSmtpConfigurationsExecute(r ApiListSmtpConfigurationsRequest) ([]NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSMTPEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSmtpConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSmtpSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListSmtpSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListSmtpSelectorsExecute(r)
}

/*
ListSmtpSelectors Method for ListSmtpSelectors

List selectors mapping events for delivery to a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListSmtpSelectorsRequest
*/
func (a *DefaultApiService) ListSmtpSelectors(ctx context.Context, uuid string) ApiListSmtpSelectorsRequest {
	return ApiListSmtpSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListSmtpSelectorsExecute(r ApiListSmtpSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSmtpSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTeamsConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListTeamsConfigurationsRequest) Execute() ([]NotificationTeamsEndpointConfiguration, *http.Response, error) {
	return r.ApiService.ListTeamsConfigurationsExecute(r)
}

/*
ListTeamsConfigurations Method for ListTeamsConfigurations

List Teams endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTeamsConfigurationsRequest
*/
func (a *DefaultApiService) ListTeamsConfigurations(ctx context.Context) ApiListTeamsConfigurationsRequest {
	return ApiListTeamsConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationTeamsEndpointConfiguration
func (a *DefaultApiService) ListTeamsConfigurationsExecute(r ApiListTeamsConfigurationsRequest) ([]NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationTeamsEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTeamsConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTeamsSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListTeamsSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListTeamsSelectorsExecute(r)
}

/*
ListTeamsSelectors Method for ListTeamsSelectors

List selectors mapping events for delivery to a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListTeamsSelectorsRequest
*/
func (a *DefaultApiService) ListTeamsSelectors(ctx context.Context, uuid string) ApiListTeamsSelectorsRequest {
	return ApiListTeamsSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListTeamsSelectorsExecute(r ApiListTeamsSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTeamsSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUserRolesRequest struct {
	ctx context.Context
	ApiService DefaultApi
	username string
	forAccount *string
	role *string
}

func (r ApiListUserRolesRequest) ForAccount(forAccount string) ApiListUserRolesRequest {
	r.forAccount = &forAccount
	return r
}

func (r ApiListUserRolesRequest) Role(role string) ApiListUserRolesRequest {
	r.role = &role
	return r
}

func (r ApiListUserRolesRequest) Execute() ([]RbacManagerRoleMembership, *http.Response, error) {
	return r.ApiService.ListUserRolesExecute(r)
}

/*
ListUserRoles List the roles for which the requested user is a member

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username
 @return ApiListUserRolesRequest
*/
func (a *DefaultApiService) ListUserRoles(ctx context.Context, username string) ApiListUserRolesRequest {
	return ApiListUserRolesRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return []RbacManagerRoleMembership
func (a *DefaultApiService) ListUserRolesExecute(r ApiListUserRolesRequest) ([]RbacManagerRoleMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RbacManagerRoleMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListUserRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/users/{username}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forAccount != nil {
		localVarQueryParams.Add("for_account", parameterToString(*r.forAccount, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWebhookConfigurationsRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiListWebhookConfigurationsRequest) Execute() ([]NotificationWebhookEndpointConfiguration, *http.Response, error) {
	return r.ApiService.ListWebhookConfigurationsExecute(r)
}

/*
ListWebhookConfigurations Method for ListWebhookConfigurations

List Webhook endpoint configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListWebhookConfigurationsRequest
*/
func (a *DefaultApiService) ListWebhookConfigurations(ctx context.Context) ApiListWebhookConfigurationsRequest {
	return ApiListWebhookConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationWebhookEndpointConfiguration
func (a *DefaultApiService) ListWebhookConfigurationsExecute(r ApiListWebhookConfigurationsRequest) ([]NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationWebhookEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWebhookConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWebhookSelectorsRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiListWebhookSelectorsRequest) Execute() ([]NotificationSelector, *http.Response, error) {
	return r.ApiService.ListWebhookSelectorsExecute(r)
}

/*
ListWebhookSelectors Method for ListWebhookSelectors

List selectors mapping events for delivery to a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiListWebhookSelectorsRequest
*/
func (a *DefaultApiService) ListWebhookSelectors(ctx context.Context, uuid string) ApiListWebhookSelectorsRequest {
	return ApiListWebhookSelectorsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []NotificationSelector
func (a *DefaultApiService) ListWebhookSelectorsExecute(r ApiListWebhookSelectorsRequest) ([]NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListWebhookSelectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/selectors"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMyRolesRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiMyRolesRequest) Execute() ([]RbacManagerAccountRole, *http.Response, error) {
	return r.ApiService.MyRolesExecute(r)
}

/*
MyRoles List the roles for which the authenticated user is a member

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMyRolesRequest
*/
func (a *DefaultApiService) MyRoles(ctx context.Context) ApiMyRolesRequest {
	return ApiMyRolesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RbacManagerAccountRole
func (a *DefaultApiService) MyRolesExecute(r ApiMyRolesRequest) ([]RbacManagerAccountRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RbacManagerAccountRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MyRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/my-roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPingRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiPingRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Method for Ping

Simple status check

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPingRequest
*/
func (a *DefaultApiService) Ping(ctx context.Context) ApiPingRequest {
	return ApiPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) PingExecute(r ApiPingRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Ping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeOauthTokenRequest struct {
	ctx context.Context
	ApiService DefaultApi
	token *string
	tokenTypeHint *string
}

// The token to be revoked
func (r ApiRevokeOauthTokenRequest) Token(token string) ApiRevokeOauthTokenRequest {
	r.token = &token
	return r
}

// A hint about the type of token to be revoked
func (r ApiRevokeOauthTokenRequest) TokenTypeHint(tokenTypeHint string) ApiRevokeOauthTokenRequest {
	r.tokenTypeHint = &tokenTypeHint
	return r
}

func (r ApiRevokeOauthTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevokeOauthTokenExecute(r)
}

/*
RevokeOauthToken Method for RevokeOauthToken

Revoke a refresh token previously requested from /oauth/token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeOauthTokenRequest
*/
func (a *DefaultApiService) RevokeOauthToken(ctx context.Context) ApiRevokeOauthTokenRequest {
	return ApiRevokeOauthTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) RevokeOauthTokenExecute(r ApiRevokeOauthTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RevokeOauthToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/revoke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.token != nil {
		localVarFormParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.tokenTypeHint != nil {
		localVarFormParams.Add("token_type_hint", parameterToString(*r.tokenTypeHint, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RevokeOauthToken400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSamlLoginRequest struct {
	ctx context.Context
	ApiService DefaultApi
	idpName string
}

func (r ApiSamlLoginRequest) Execute() (*RbacManagerTokenResponse, *http.Response, error) {
	return r.ApiService.SamlLoginExecute(r)
}

/*
SamlLogin Method for SamlLogin

Initiate an SP-initiated login sequence for the Idp. The SP will respond with the SAML AuthN Request the client must send to the Idp URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlLoginRequest
*/
func (a *DefaultApiService) SamlLogin(ctx context.Context, idpName string) ApiSamlLoginRequest {
	return ApiSamlLoginRequest{
		ApiService: a,
		ctx: ctx,
		idpName: idpName,
	}
}

// Execute executes the request
//  @return RbacManagerTokenResponse
func (a *DefaultApiService) SamlLoginExecute(r ApiSamlLoginRequest) (*RbacManagerTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SamlLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/login/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", url.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSamlSsoRequest struct {
	ctx context.Context
	ApiService DefaultApi
	idpName string
}

func (r ApiSamlSsoRequest) Execute() (*RbacManagerTokenResponse, *http.Response, error) {
	return r.ApiService.SamlSsoExecute(r)
}

/*
SamlSso Method for SamlSso

Perform a login using a SAML assertion, no HTTP auth is required as the SAML assertion is considered the authenticating token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idpName
 @return ApiSamlSsoRequest
*/
func (a *DefaultApiService) SamlSso(ctx context.Context, idpName string) ApiSamlSsoRequest {
	return ApiSamlSsoRequest{
		ApiService: a,
		ctx: ctx,
		idpName: idpName,
	}
}

// Execute executes the request
//  @return RbacManagerTokenResponse
func (a *DefaultApiService) SamlSsoExecute(r ApiSamlSsoRequest) (*RbacManagerTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SamlSso")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/sso/{idp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"idp_name"+"}", url.PathEscape(parameterToString(r.idpName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationGitHubEndpointConfigurationPost
}

func (r ApiTestGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPost) ApiTestGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestGithubConfigurationRequest) Execute() (*NotificationGitHubTestResult, *http.Response, error) {
	return r.ApiService.TestGithubConfigurationExecute(r)
}

/*
TestGithubConfiguration Method for TestGithubConfiguration

Test GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestGithubConfigurationRequest
*/
func (a *DefaultApiService) TestGithubConfiguration(ctx context.Context) ApiTestGithubConfigurationRequest {
	return ApiTestGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationGitHubTestResult
func (a *DefaultApiService) TestGithubConfigurationExecute(r ApiTestGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestGithubConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationJiraEndpointConfigurationPost
}

func (r ApiTestJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPost) ApiTestJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestJiraConfigurationRequest) Execute() (*NotificationJiraTestResult, *http.Response, error) {
	return r.ApiService.TestJiraConfigurationExecute(r)
}

/*
TestJiraConfiguration Method for TestJiraConfiguration

Test Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestJiraConfigurationRequest
*/
func (a *DefaultApiService) TestJiraConfiguration(ctx context.Context) ApiTestJiraConfigurationRequest {
	return ApiTestJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationJiraTestResult
func (a *DefaultApiService) TestJiraConfigurationExecute(r ApiTestJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestJiraConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiTestSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiTestSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestSlackConfigurationRequest) Execute() (*NotificationSlackTestResult, *http.Response, error) {
	return r.ApiService.TestSlackConfigurationExecute(r)
}

/*
TestSlackConfiguration Method for TestSlackConfiguration

Test Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSlackConfigurationRequest
*/
func (a *DefaultApiService) TestSlackConfiguration(ctx context.Context) ApiTestSlackConfigurationRequest {
	return ApiTestSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSlackTestResult
func (a *DefaultApiService) TestSlackConfigurationExecute(r ApiTestSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestSlackConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiTestSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiTestSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestSmtpConfigurationRequest) Execute() (*NotificationSMTPTestResult, *http.Response, error) {
	return r.ApiService.TestSmtpConfigurationExecute(r)
}

/*
TestSmtpConfiguration Method for TestSmtpConfiguration

Test SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestSmtpConfiguration(ctx context.Context) ApiTestSmtpConfigurationRequest {
	return ApiTestSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationSMTPTestResult
func (a *DefaultApiService) TestSmtpConfigurationExecute(r ApiTestSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestSmtpConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredGithubConfigurationRequest) Execute() (*NotificationGitHubTestResult, *http.Response, error) {
	return r.ApiService.TestStoredGithubConfigurationExecute(r)
}

/*
TestStoredGithubConfiguration Method for TestStoredGithubConfiguration

Test stored GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredGithubConfigurationRequest
*/
func (a *DefaultApiService) TestStoredGithubConfiguration(ctx context.Context, uuid string) ApiTestStoredGithubConfigurationRequest {
	return ApiTestStoredGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubTestResult
func (a *DefaultApiService) TestStoredGithubConfigurationExecute(r ApiTestStoredGithubConfigurationRequest) (*NotificationGitHubTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredGithubConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredJiraConfigurationRequest) Execute() (*NotificationJiraTestResult, *http.Response, error) {
	return r.ApiService.TestStoredJiraConfigurationExecute(r)
}

/*
TestStoredJiraConfiguration Method for TestStoredJiraConfiguration

Test stored Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredJiraConfigurationRequest
*/
func (a *DefaultApiService) TestStoredJiraConfiguration(ctx context.Context, uuid string) ApiTestStoredJiraConfigurationRequest {
	return ApiTestStoredJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraTestResult
func (a *DefaultApiService) TestStoredJiraConfigurationExecute(r ApiTestStoredJiraConfigurationRequest) (*NotificationJiraTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredJiraConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredSlackConfigurationRequest) Execute() (*NotificationSlackTestResult, *http.Response, error) {
	return r.ApiService.TestStoredSlackConfigurationExecute(r)
}

/*
TestStoredSlackConfiguration Method for TestStoredSlackConfiguration

Test stored Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSlackConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSlackConfiguration(ctx context.Context, uuid string) ApiTestStoredSlackConfigurationRequest {
	return ApiTestStoredSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackTestResult
func (a *DefaultApiService) TestStoredSlackConfigurationExecute(r ApiTestStoredSlackConfigurationRequest) (*NotificationSlackTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredSlackConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredSmtpConfigurationRequest) Execute() (*NotificationSMTPTestResult, *http.Response, error) {
	return r.ApiService.TestStoredSmtpConfigurationExecute(r)
}

/*
TestStoredSmtpConfiguration Method for TestStoredSmtpConfiguration

Test stored SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredSmtpConfigurationRequest
*/
func (a *DefaultApiService) TestStoredSmtpConfiguration(ctx context.Context, uuid string) ApiTestStoredSmtpConfigurationRequest {
	return ApiTestStoredSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPTestResult
func (a *DefaultApiService) TestStoredSmtpConfigurationExecute(r ApiTestStoredSmtpConfigurationRequest) (*NotificationSMTPTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredSmtpConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredTeamsConfigurationRequest) Execute() (*NotificationTeamsTestResult, *http.Response, error) {
	return r.ApiService.TestStoredTeamsConfigurationExecute(r)
}

/*
TestStoredTeamsConfiguration Method for TestStoredTeamsConfiguration

Test stored Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestStoredTeamsConfiguration(ctx context.Context, uuid string) ApiTestStoredTeamsConfigurationRequest {
	return ApiTestStoredTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsTestResult
func (a *DefaultApiService) TestStoredTeamsConfigurationExecute(r ApiTestStoredTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredTeamsConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestStoredWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
}

func (r ApiTestStoredWebhookConfigurationRequest) Execute() (*NotificationWebhookTestResult, *http.Response, error) {
	return r.ApiService.TestStoredWebhookConfigurationExecute(r)
}

/*
TestStoredWebhookConfiguration Method for TestStoredWebhookConfiguration

Test stored Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiTestStoredWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestStoredWebhookConfiguration(ctx context.Context, uuid string) ApiTestStoredWebhookConfigurationRequest {
	return ApiTestStoredWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookTestResult
func (a *DefaultApiService) TestStoredWebhookConfigurationExecute(r ApiTestStoredWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestStoredWebhookConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiTestTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiTestTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestTeamsConfigurationRequest) Execute() (*NotificationTeamsTestResult, *http.Response, error) {
	return r.ApiService.TestTeamsConfigurationExecute(r)
}

/*
TestTeamsConfiguration Method for TestTeamsConfiguration

Test Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestTeamsConfigurationRequest
*/
func (a *DefaultApiService) TestTeamsConfiguration(ctx context.Context) ApiTestTeamsConfigurationRequest {
	return ApiTestTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationTeamsTestResult
func (a *DefaultApiService) TestTeamsConfigurationExecute(r ApiTestTeamsConfigurationRequest) (*NotificationTeamsTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestTeamsConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiTestWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiTestWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiTestWebhookConfigurationRequest) Execute() (*NotificationWebhookTestResult, *http.Response, error) {
	return r.ApiService.TestWebhookConfigurationExecute(r)
}

/*
TestWebhookConfiguration Method for TestWebhookConfiguration

Test Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestWebhookConfigurationRequest
*/
func (a *DefaultApiService) TestWebhookConfiguration(ctx context.Context) ApiTestWebhookConfigurationRequest {
	return ApiTestWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationWebhookTestResult
func (a *DefaultApiService) TestWebhookConfigurationExecute(r ApiTestWebhookConfigurationRequest) (*NotificationWebhookTestResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookTestResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.TestWebhookConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEndpointStatusRequest struct {
	ctx context.Context
	ApiService DefaultApi
	name string
	status *NotificationEndpointEnabledStatus
}

func (r ApiUpdateEndpointStatusRequest) Status(status NotificationEndpointEnabledStatus) ApiUpdateEndpointStatusRequest {
	r.status = &status
	return r
}

func (r ApiUpdateEndpointStatusRequest) Execute() (*NotificationEndpointEnabledStatus, *http.Response, error) {
	return r.ApiService.UpdateEndpointStatusExecute(r)
}

/*
UpdateEndpointStatus Method for UpdateEndpointStatus

Update enabled status of an endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateEndpointStatusRequest
*/
func (a *DefaultApiService) UpdateEndpointStatus(ctx context.Context, name string) ApiUpdateEndpointStatusRequest {
	return ApiUpdateEndpointStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return NotificationEndpointEnabledStatus
func (a *DefaultApiService) UpdateEndpointStatusExecute(r ApiUpdateEndpointStatusRequest) (*NotificationEndpointEnabledStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationEndpointEnabledStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateEndpointStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.status
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGithubConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationGitHubEndpointConfigurationPut
}

func (r ApiUpdateGithubConfigurationRequest) Configuration(configuration NotificationGitHubEndpointConfigurationPut) ApiUpdateGithubConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateGithubConfigurationRequest) Execute() (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.UpdateGithubConfigurationExecute(r)
}

/*
UpdateGithubConfiguration Method for UpdateGithubConfiguration

Update a GitHub endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateGithubConfigurationRequest
*/
func (a *DefaultApiService) UpdateGithubConfiguration(ctx context.Context, uuid string) ApiUpdateGithubConfigurationRequest {
	return ApiUpdateGithubConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationGitHubEndpointConfigurationBase
func (a *DefaultApiService) UpdateGithubConfigurationExecute(r ApiUpdateGithubConfigurationRequest) (*NotificationGitHubEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationGitHubEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGithubConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGithubSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateGithubSelectorRequest) Selector(selector NotificationSelector) ApiUpdateGithubSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateGithubSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateGithubSelectorExecute(r)
}

/*
UpdateGithubSelector Method for UpdateGithubSelector

Update a selector mapped to a GitHub endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateGithubSelectorRequest
*/
func (a *DefaultApiService) UpdateGithubSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateGithubSelectorRequest {
	return ApiUpdateGithubSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateGithubSelectorExecute(r ApiUpdateGithubSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGithubSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/github/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIdpRequest struct {
	ctx context.Context
	ApiService DefaultApi
	name string
	configuration *RbacManagerSamlConfiguration
}

func (r ApiUpdateIdpRequest) Configuration(configuration RbacManagerSamlConfiguration) ApiUpdateIdpRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateIdpRequest) Execute() (*RbacManagerSamlConfiguration, *http.Response, error) {
	return r.ApiService.UpdateIdpExecute(r)
}

/*
UpdateIdp Method for UpdateIdp

Update an existing Identity Provider configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiUpdateIdpRequest
*/
func (a *DefaultApiService) UpdateIdp(ctx context.Context, name string) ApiUpdateIdpRequest {
	return ApiUpdateIdpRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RbacManagerSamlConfiguration
func (a *DefaultApiService) UpdateIdpExecute(r ApiUpdateIdpRequest) (*RbacManagerSamlConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RbacManagerSamlConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateIdp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rbac-manager/saml/idps/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v RbacManagerApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJiraConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationJiraEndpointConfigurationPut
}

func (r ApiUpdateJiraConfigurationRequest) Configuration(configuration NotificationJiraEndpointConfigurationPut) ApiUpdateJiraConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateJiraConfigurationRequest) Execute() (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	return r.ApiService.UpdateJiraConfigurationExecute(r)
}

/*
UpdateJiraConfiguration Method for UpdateJiraConfiguration

Update a Jira endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateJiraConfigurationRequest
*/
func (a *DefaultApiService) UpdateJiraConfiguration(ctx context.Context, uuid string) ApiUpdateJiraConfigurationRequest {
	return ApiUpdateJiraConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationJiraEndpointConfigurationBase
func (a *DefaultApiService) UpdateJiraConfigurationExecute(r ApiUpdateJiraConfigurationRequest) (*NotificationJiraEndpointConfigurationBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationJiraEndpointConfigurationBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateJiraConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateJiraSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateJiraSelectorRequest) Selector(selector NotificationSelector) ApiUpdateJiraSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateJiraSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateJiraSelectorExecute(r)
}

/*
UpdateJiraSelector Method for UpdateJiraSelector

Update a selector mapped to a Jira endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateJiraSelectorRequest
*/
func (a *DefaultApiService) UpdateJiraSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateJiraSelectorRequest {
	return ApiUpdateJiraSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateJiraSelectorExecute(r ApiUpdateJiraSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateJiraSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/jira/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSlackConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationSlackEndpointConfiguration
}

func (r ApiUpdateSlackConfigurationRequest) Configuration(configuration NotificationSlackEndpointConfiguration) ApiUpdateSlackConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateSlackConfigurationRequest) Execute() (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	return r.ApiService.UpdateSlackConfigurationExecute(r)
}

/*
UpdateSlackConfiguration Method for UpdateSlackConfiguration

Update a Slack endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSlackConfigurationRequest
*/
func (a *DefaultApiService) UpdateSlackConfiguration(ctx context.Context, uuid string) ApiUpdateSlackConfigurationRequest {
	return ApiUpdateSlackConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSlackEndpointConfiguration
func (a *DefaultApiService) UpdateSlackConfigurationExecute(r ApiUpdateSlackConfigurationRequest) (*NotificationSlackEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSlackEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSlackConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSlackSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateSlackSelectorRequest) Selector(selector NotificationSelector) ApiUpdateSlackSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateSlackSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateSlackSelectorExecute(r)
}

/*
UpdateSlackSelector Method for UpdateSlackSelector

Update a selector mapped to a Slack endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateSlackSelectorRequest
*/
func (a *DefaultApiService) UpdateSlackSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSlackSelectorRequest {
	return ApiUpdateSlackSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateSlackSelectorExecute(r ApiUpdateSlackSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSlackSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/slack/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSmtpConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationSMTPEndpointConfiguration
}

func (r ApiUpdateSmtpConfigurationRequest) Configuration(configuration NotificationSMTPEndpointConfiguration) ApiUpdateSmtpConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateSmtpConfigurationRequest) Execute() (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	return r.ApiService.UpdateSmtpConfigurationExecute(r)
}

/*
UpdateSmtpConfiguration Method for UpdateSmtpConfiguration

Update a SMTP endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateSmtpConfigurationRequest
*/
func (a *DefaultApiService) UpdateSmtpConfiguration(ctx context.Context, uuid string) ApiUpdateSmtpConfigurationRequest {
	return ApiUpdateSmtpConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationSMTPEndpointConfiguration
func (a *DefaultApiService) UpdateSmtpConfigurationExecute(r ApiUpdateSmtpConfigurationRequest) (*NotificationSMTPEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSMTPEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSmtpConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSmtpSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateSmtpSelectorRequest) Selector(selector NotificationSelector) ApiUpdateSmtpSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateSmtpSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateSmtpSelectorExecute(r)
}

/*
UpdateSmtpSelector Method for UpdateSmtpSelector

Update a selector mapped to a SMTP endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateSmtpSelectorRequest
*/
func (a *DefaultApiService) UpdateSmtpSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateSmtpSelectorRequest {
	return ApiUpdateSmtpSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateSmtpSelectorExecute(r ApiUpdateSmtpSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSmtpSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/smtp/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeamsConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationTeamsEndpointConfiguration
}

func (r ApiUpdateTeamsConfigurationRequest) Configuration(configuration NotificationTeamsEndpointConfiguration) ApiUpdateTeamsConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateTeamsConfigurationRequest) Execute() (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	return r.ApiService.UpdateTeamsConfigurationExecute(r)
}

/*
UpdateTeamsConfiguration Method for UpdateTeamsConfiguration

Update a Teams endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateTeamsConfigurationRequest
*/
func (a *DefaultApiService) UpdateTeamsConfiguration(ctx context.Context, uuid string) ApiUpdateTeamsConfigurationRequest {
	return ApiUpdateTeamsConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationTeamsEndpointConfiguration
func (a *DefaultApiService) UpdateTeamsConfigurationExecute(r ApiUpdateTeamsConfigurationRequest) (*NotificationTeamsEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationTeamsEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTeamsConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeamsSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateTeamsSelectorRequest) Selector(selector NotificationSelector) ApiUpdateTeamsSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateTeamsSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateTeamsSelectorExecute(r)
}

/*
UpdateTeamsSelector Method for UpdateTeamsSelector

Update a selector mapped to a Teams endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateTeamsSelectorRequest
*/
func (a *DefaultApiService) UpdateTeamsSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateTeamsSelectorRequest {
	return ApiUpdateTeamsSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateTeamsSelectorExecute(r ApiUpdateTeamsSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTeamsSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/teams/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookConfigurationRequest struct {
	ctx context.Context
	ApiService DefaultApi
	uuid string
	configuration *NotificationWebhookEndpointConfiguration
}

func (r ApiUpdateWebhookConfigurationRequest) Configuration(configuration NotificationWebhookEndpointConfiguration) ApiUpdateWebhookConfigurationRequest {
	r.configuration = &configuration
	return r
}

func (r ApiUpdateWebhookConfigurationRequest) Execute() (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	return r.ApiService.UpdateWebhookConfigurationExecute(r)
}

/*
UpdateWebhookConfiguration Method for UpdateWebhookConfiguration

Update a Webhook endpoint configuration by it's UUID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid
 @return ApiUpdateWebhookConfigurationRequest
*/
func (a *DefaultApiService) UpdateWebhookConfiguration(ctx context.Context, uuid string) ApiUpdateWebhookConfigurationRequest {
	return ApiUpdateWebhookConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return NotificationWebhookEndpointConfiguration
func (a *DefaultApiService) UpdateWebhookConfigurationExecute(r ApiUpdateWebhookConfigurationRequest) (*NotificationWebhookEndpointConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationWebhookEndpointConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateWebhookConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configuration == nil {
		return localVarReturnValue, nil, reportError("configuration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configuration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookSelectorRequest struct {
	ctx context.Context
	ApiService DefaultApi
	configurationUuid string
	selectorUuid string
	selector *NotificationSelector
}

func (r ApiUpdateWebhookSelectorRequest) Selector(selector NotificationSelector) ApiUpdateWebhookSelectorRequest {
	r.selector = &selector
	return r
}

func (r ApiUpdateWebhookSelectorRequest) Execute() (*NotificationSelector, *http.Response, error) {
	return r.ApiService.UpdateWebhookSelectorExecute(r)
}

/*
UpdateWebhookSelector Method for UpdateWebhookSelector

Update a selector mapped to a Webhook endpoint configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param configurationUuid
 @param selectorUuid
 @return ApiUpdateWebhookSelectorRequest
*/
func (a *DefaultApiService) UpdateWebhookSelector(ctx context.Context, configurationUuid string, selectorUuid string) ApiUpdateWebhookSelectorRequest {
	return ApiUpdateWebhookSelectorRequest{
		ApiService: a,
		ctx: ctx,
		configurationUuid: configurationUuid,
		selectorUuid: selectorUuid,
	}
}

// Execute executes the request
//  @return NotificationSelector
func (a *DefaultApiService) UpdateWebhookSelectorExecute(r ApiUpdateWebhookSelectorRequest) (*NotificationSelector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationSelector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateWebhookSelector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/endpoints/webhook/configurations/{configuration_uuid}/selectors/{selector_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"configuration_uuid"+"}", url.PathEscape(parameterToString(r.configurationUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"selector_uuid"+"}", url.PathEscape(parameterToString(r.selectorUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return localVarReturnValue, nil, reportError("selector is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selector
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVersionCheckRequest struct {
	ctx context.Context
	ApiService DefaultApi
}

func (r ApiVersionCheckRequest) Execute() (*ServiceVersion, *http.Response, error) {
	return r.ApiService.VersionCheckExecute(r)
}

/*
VersionCheck Method for VersionCheck

Returns the version object for the service, including db schema version info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVersionCheckRequest
*/
func (a *DefaultApiService) VersionCheck(ctx context.Context) ApiVersionCheckRequest {
	return ApiVersionCheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceVersion
func (a *DefaultApiService) VersionCheckExecute(r ApiVersionCheckRequest) (*ServiceVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VersionCheck")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
