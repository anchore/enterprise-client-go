/*
Anchore API

This is the Anchore API. Provides the external API for users of Anchore Enterprise.

API version: 2.7.2
Contact: dev@anchore.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package enterprise

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ImagesApi interface {

	/*
	AddImage Submit a new image for analysis by the engine

	Creates a new analysis task that is executed asynchronously

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddImageRequest
	*/
	AddImage(ctx context.Context) ApiAddImageRequest

	// AddImageExecute executes the request
	//  @return AnchoreImage
	AddImageExecute(r ApiAddImageRequest) (*AnchoreImage, *http.Response, error)

	/*
	DeleteImage Delete an image analysis

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiDeleteImageRequest
	*/
	DeleteImage(ctx context.Context, imageDigest string) ApiDeleteImageRequest

	// DeleteImageExecute executes the request
	//  @return DeleteImageResponse
	DeleteImageExecute(r ApiDeleteImageRequest) (*DeleteImageResponse, *http.Response, error)

	/*
	DeleteImagesAsync Bulk mark images for deletion

	Delete analysis for image digests in the list asynchronously

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteImagesAsyncRequest
	*/
	DeleteImagesAsync(ctx context.Context) ApiDeleteImagesAsyncRequest

	// DeleteImagesAsyncExecute executes the request
	//  @return []DeleteImageResponse
	DeleteImagesAsyncExecute(r ApiDeleteImagesAsyncRequest) ([]DeleteImageResponse, *http.Response, error)

	/*
	GetImage Get image metadata

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageRequest
	*/
	GetImage(ctx context.Context, imageDigest string) ApiGetImageRequest

	// GetImageExecute executes the request
	//  @return AnchoreImage
	GetImageExecute(r ApiGetImageRequest) (*AnchoreImage, *http.Response, error)

	/*
	GetImageAncestors Return the list of ancestor images for the given image

	Returns list of ancestor images, which are the images that form the base layers of the image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageAncestorsRequest
	*/
	GetImageAncestors(ctx context.Context, imageDigest string) ApiGetImageAncestorsRequest

	// GetImageAncestorsExecute executes the request
	//  @return []ImageAncestor
	GetImageAncestorsExecute(r ApiGetImageAncestorsRequest) ([]ImageAncestor, *http.Response, error)

	/*
	GetImageContentByType Get the content of an image by type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@param contentType
	@return ApiGetImageContentByTypeRequest
	*/
	GetImageContentByType(ctx context.Context, imageDigest string, contentType string) ApiGetImageContentByTypeRequest

	// GetImageContentByTypeExecute executes the request
	//  @return ContentPackageResponse
	GetImageContentByTypeExecute(r ApiGetImageContentByTypeRequest) (*ContentPackageResponse, *http.Response, error)

	/*
	GetImageContentByTypeFiles Get the content of an image by type files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageContentByTypeFilesRequest
	*/
	GetImageContentByTypeFiles(ctx context.Context, imageDigest string) ApiGetImageContentByTypeFilesRequest

	// GetImageContentByTypeFilesExecute executes the request
	//  @return ContentFilesResponse
	GetImageContentByTypeFilesExecute(r ApiGetImageContentByTypeFilesRequest) (*ContentFilesResponse, *http.Response, error)

	/*
	GetImageContentByTypeJavaPackage Get the content of an image by type java

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageContentByTypeJavaPackageRequest
	*/
	GetImageContentByTypeJavaPackage(ctx context.Context, imageDigest string) ApiGetImageContentByTypeJavaPackageRequest

	// GetImageContentByTypeJavaPackageExecute executes the request
	//  @return ContentJavaPackageResponse
	GetImageContentByTypeJavaPackageExecute(r ApiGetImageContentByTypeJavaPackageRequest) (*ContentJavaPackageResponse, *http.Response, error)

	/*
	GetImageContentByTypeMalware Get the content of an image by type malware

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageContentByTypeMalwareRequest
	*/
	GetImageContentByTypeMalware(ctx context.Context, imageDigest string) ApiGetImageContentByTypeMalwareRequest

	// GetImageContentByTypeMalwareExecute executes the request
	//  @return ContentMalwareResponse
	GetImageContentByTypeMalwareExecute(r ApiGetImageContentByTypeMalwareRequest) (*ContentMalwareResponse, *http.Response, error)

	/*
	GetImageContentSummary Get image content summary

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageContentSummaryRequest
	*/
	GetImageContentSummary(ctx context.Context, imageDigest string) ApiGetImageContentSummaryRequest

	// GetImageContentSummaryExecute executes the request
	//  @return ImageContentSummary
	GetImageContentSummaryExecute(r ApiGetImageContentSummaryRequest) (*ImageContentSummary, *http.Response, error)

	/*
	GetImageMetadataByType Get the metadata of an image by type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@param metadataType
	@return ApiGetImageMetadataByTypeRequest
	*/
	GetImageMetadataByType(ctx context.Context, imageDigest string, metadataType string) ApiGetImageMetadataByTypeRequest

	// GetImageMetadataByTypeExecute executes the request
	//  @return MetadataResponse
	GetImageMetadataByTypeExecute(r ApiGetImageMetadataByTypeRequest) (*MetadataResponse, *http.Response, error)

	/*
	GetImagePolicyCheckByDigest Check policy evaluation status for image

	Get the policy evaluation for the given image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImagePolicyCheckByDigestRequest
	*/
	GetImagePolicyCheckByDigest(ctx context.Context, imageDigest string) ApiGetImagePolicyCheckByDigestRequest

	// GetImagePolicyCheckByDigestExecute executes the request
	//  @return PolicyEvaluation
	GetImagePolicyCheckByDigestExecute(r ApiGetImagePolicyCheckByDigestRequest) (*PolicyEvaluation, *http.Response, error)

	/*
	GetImageSbomCyclonedxJson Get image sbom in the CycloneDX format

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageSbomCyclonedxJsonRequest
	*/
	GetImageSbomCyclonedxJson(ctx context.Context, imageDigest string) ApiGetImageSbomCyclonedxJsonRequest

	// GetImageSbomCyclonedxJsonExecute executes the request
	//  @return string
	GetImageSbomCyclonedxJsonExecute(r ApiGetImageSbomCyclonedxJsonRequest) (string, *http.Response, error)

	/*
	GetImageSbomNativeJson Get image sbom in the native Anchore format

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageSbomNativeJsonRequest
	*/
	GetImageSbomNativeJson(ctx context.Context, imageDigest string) ApiGetImageSbomNativeJsonRequest

	// GetImageSbomNativeJsonExecute executes the request
	//  @return string
	GetImageSbomNativeJsonExecute(r ApiGetImageSbomNativeJsonRequest) (string, *http.Response, error)

	/*
	GetImageSbomSpdxJson Get image sbom in the SPDX format

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageSbomSpdxJsonRequest
	*/
	GetImageSbomSpdxJson(ctx context.Context, imageDigest string) ApiGetImageSbomSpdxJsonRequest

	// GetImageSbomSpdxJsonExecute executes the request
	//  @return string
	GetImageSbomSpdxJsonExecute(r ApiGetImageSbomSpdxJsonRequest) (string, *http.Response, error)

	/*
	GetImageVulnerabilitiesByDigest Get vulnerabilities by type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@param vulnType
	@return ApiGetImageVulnerabilitiesByDigestRequest
	*/
	GetImageVulnerabilitiesByDigest(ctx context.Context, imageDigest string, vulnType string) ApiGetImageVulnerabilitiesByDigestRequest

	// GetImageVulnerabilitiesByDigestExecute executes the request
	//  @return ImagePackageVulnerabilityResponse
	GetImageVulnerabilitiesByDigestExecute(r ApiGetImageVulnerabilitiesByDigestRequest) (*ImagePackageVulnerabilityResponse, *http.Response, error)

	/*
	GetImageVulnerabilityTypes Get vulnerability types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiGetImageVulnerabilityTypesRequest
	*/
	GetImageVulnerabilityTypes(ctx context.Context, imageDigest string) ApiGetImageVulnerabilityTypesRequest

	// GetImageVulnerabilityTypesExecute executes the request
	//  @return []string
	GetImageVulnerabilityTypesExecute(r ApiGetImageVulnerabilityTypesRequest) ([]string, *http.Response, error)

	/*
	ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListFileContentSearchResultsRequest
	*/
	ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest

	// ListFileContentSearchResultsExecute executes the request
	//  @return []FileContentSearchResult
	ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error)

	/*
	ListImageContent List image content types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListImageContentRequest
	*/
	ListImageContent(ctx context.Context, imageDigest string) ApiListImageContentRequest

	// ListImageContentExecute executes the request
	//  @return []string
	ListImageContentExecute(r ApiListImageContentRequest) ([]string, *http.Response, error)

	/*
	ListImageMetadata List image metadata types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListImageMetadataRequest
	*/
	ListImageMetadata(ctx context.Context, imageDigest string) ApiListImageMetadataRequest

	// ListImageMetadataExecute executes the request
	//  @return []string
	ListImageMetadataExecute(r ApiListImageMetadataRequest) ([]string, *http.Response, error)

	/*
	ListImages List all visible images

	List all images visible to the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListImagesRequest
	*/
	ListImages(ctx context.Context) ApiListImagesRequest

	// ListImagesExecute executes the request
	//  @return AnchoreImageList
	ListImagesExecute(r ApiListImagesRequest) (*AnchoreImageList, *http.Response, error)

	/*
	ListRetrievedFiles Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListRetrievedFilesRequest
	*/
	ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest

	// ListRetrievedFilesExecute executes the request
	//  @return []RetrievedFile
	ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error)

	/*
	ListSecretSearchResults Return a list of analyzer artifacts of the specified type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param imageDigest
	@return ApiListSecretSearchResultsRequest
	*/
	ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest

	// ListSecretSearchResultsExecute executes the request
	//  @return []SecretSearchResult
	ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error)

	/*
	SummaryImageCounts Image summary counts

	Count tags and images by analysis status

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSummaryImageCountsRequest
	*/
	SummaryImageCounts(ctx context.Context) ApiSummaryImageCountsRequest

	// SummaryImageCountsExecute executes the request
	//  @return AnchoreImageSummaryCounts
	SummaryImageCountsExecute(r ApiSummaryImageCountsRequest) (*AnchoreImageSummaryCounts, *http.Response, error)

	/*
	SummaryImageTags Summarize image tags

	List all image tags visible to the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSummaryImageTagsRequest
	*/
	SummaryImageTags(ctx context.Context) ApiSummaryImageTagsRequest

	// SummaryImageTagsExecute executes the request
	//  @return AnchoreImageTagSummaryList
	SummaryImageTagsExecute(r ApiSummaryImageTagsRequest) (*AnchoreImageTagSummaryList, *http.Response, error)
}

// ImagesApiService ImagesApi service
type ImagesApiService service

type ApiAddImageRequest struct {
	ctx context.Context
	ApiService ImagesApi
	image *ImageAnalysisRequest
	force *bool
	autoSubscribe *bool
	xAnchoreAccount *string
}

func (r ApiAddImageRequest) Image(image ImageAnalysisRequest) ApiAddImageRequest {
	r.image = &image
	return r
}

// Override any existing entry in the system
func (r ApiAddImageRequest) Force(force bool) ApiAddImageRequest {
	r.force = &force
	return r
}

// Indicates if tag will be subscribed for registry updates monitoring
func (r ApiAddImageRequest) AutoSubscribe(autoSubscribe bool) ApiAddImageRequest {
	r.autoSubscribe = &autoSubscribe
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiAddImageRequest) XAnchoreAccount(xAnchoreAccount string) ApiAddImageRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiAddImageRequest) Execute() (*AnchoreImage, *http.Response, error) {
	return r.ApiService.AddImageExecute(r)
}

/*
AddImage Submit a new image for analysis by the engine

Creates a new analysis task that is executed asynchronously

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddImageRequest
*/
func (a *ImagesApiService) AddImage(ctx context.Context) ApiAddImageRequest {
	return ApiAddImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnchoreImage
func (a *ImagesApiService) AddImageExecute(r ApiAddImageRequest) (*AnchoreImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnchoreImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.AddImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.image == nil {
		return localVarReturnValue, nil, reportError("image is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	if r.autoSubscribe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auto_subscribe", r.autoSubscribe, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	// body params
	localVarPostBody = r.image
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteImageRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	force *bool
	xAnchoreAccount *string
}

func (r ApiDeleteImageRequest) Force(force bool) ApiDeleteImageRequest {
	r.force = &force
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDeleteImageRequest) XAnchoreAccount(xAnchoreAccount string) ApiDeleteImageRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiDeleteImageRequest) Execute() (*DeleteImageResponse, *http.Response, error) {
	return r.ApiService.DeleteImageExecute(r)
}

/*
DeleteImage Delete an image analysis

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiDeleteImageRequest
*/
func (a *ImagesApiService) DeleteImage(ctx context.Context, imageDigest string) ApiDeleteImageRequest {
	return ApiDeleteImageRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return DeleteImageResponse
func (a *ImagesApiService) DeleteImageExecute(r ApiDeleteImageRequest) (*DeleteImageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.DeleteImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteImagesAsyncRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigests *[]string
	force *bool
	xAnchoreAccount *string
}

func (r ApiDeleteImagesAsyncRequest) ImageDigests(imageDigests []string) ApiDeleteImagesAsyncRequest {
	r.imageDigests = &imageDigests
	return r
}

func (r ApiDeleteImagesAsyncRequest) Force(force bool) ApiDeleteImagesAsyncRequest {
	r.force = &force
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiDeleteImagesAsyncRequest) XAnchoreAccount(xAnchoreAccount string) ApiDeleteImagesAsyncRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiDeleteImagesAsyncRequest) Execute() ([]DeleteImageResponse, *http.Response, error) {
	return r.ApiService.DeleteImagesAsyncExecute(r)
}

/*
DeleteImagesAsync Bulk mark images for deletion

Delete analysis for image digests in the list asynchronously

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteImagesAsyncRequest
*/
func (a *ImagesApiService) DeleteImagesAsync(ctx context.Context) ApiDeleteImagesAsyncRequest {
	return ApiDeleteImagesAsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeleteImageResponse
func (a *ImagesApiService) DeleteImagesAsyncExecute(r ApiDeleteImagesAsyncRequest) ([]DeleteImageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeleteImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.DeleteImagesAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.imageDigests == nil {
		return localVarReturnValue, nil, reportError("imageDigests is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "image_digests", r.imageDigests, "form", "csv")
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageRequest) Execute() (*AnchoreImage, *http.Response, error) {
	return r.ApiService.GetImageExecute(r)
}

/*
GetImage Get image metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageRequest
*/
func (a *ImagesApiService) GetImage(ctx context.Context, imageDigest string) ApiGetImageRequest {
	return ApiGetImageRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return AnchoreImage
func (a *ImagesApiService) GetImageExecute(r ApiGetImageRequest) (*AnchoreImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnchoreImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageAncestorsRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageAncestorsRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageAncestorsRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageAncestorsRequest) Execute() ([]ImageAncestor, *http.Response, error) {
	return r.ApiService.GetImageAncestorsExecute(r)
}

/*
GetImageAncestors Return the list of ancestor images for the given image

Returns list of ancestor images, which are the images that form the base layers of the image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageAncestorsRequest
*/
func (a *ImagesApiService) GetImageAncestors(ctx context.Context, imageDigest string) ApiGetImageAncestorsRequest {
	return ApiGetImageAncestorsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []ImageAncestor
func (a *ImagesApiService) GetImageAncestorsExecute(r ApiGetImageAncestorsRequest) ([]ImageAncestor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ImageAncestor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageAncestors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/ancestors"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageContentByTypeRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	contentType string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageContentByTypeRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageContentByTypeRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageContentByTypeRequest) Execute() (*ContentPackageResponse, *http.Response, error) {
	return r.ApiService.GetImageContentByTypeExecute(r)
}

/*
GetImageContentByType Get the content of an image by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @param contentType
 @return ApiGetImageContentByTypeRequest
*/
func (a *ImagesApiService) GetImageContentByType(ctx context.Context, imageDigest string, contentType string) ApiGetImageContentByTypeRequest {
	return ApiGetImageContentByTypeRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
		contentType: contentType,
	}
}

// Execute executes the request
//  @return ContentPackageResponse
func (a *ImagesApiService) GetImageContentByTypeExecute(r ApiGetImageContentByTypeRequest) (*ContentPackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentPackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageContentByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content/{content_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"content_type"+"}", url.PathEscape(parameterValueToString(r.contentType, "contentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageContentByTypeFilesRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageContentByTypeFilesRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageContentByTypeFilesRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageContentByTypeFilesRequest) Execute() (*ContentFilesResponse, *http.Response, error) {
	return r.ApiService.GetImageContentByTypeFilesExecute(r)
}

/*
GetImageContentByTypeFiles Get the content of an image by type files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageContentByTypeFilesRequest
*/
func (a *ImagesApiService) GetImageContentByTypeFiles(ctx context.Context, imageDigest string) ApiGetImageContentByTypeFilesRequest {
	return ApiGetImageContentByTypeFilesRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return ContentFilesResponse
func (a *ImagesApiService) GetImageContentByTypeFilesExecute(r ApiGetImageContentByTypeFilesRequest) (*ContentFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageContentByTypeFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content/files"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageContentByTypeJavaPackageRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageContentByTypeJavaPackageRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageContentByTypeJavaPackageRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageContentByTypeJavaPackageRequest) Execute() (*ContentJavaPackageResponse, *http.Response, error) {
	return r.ApiService.GetImageContentByTypeJavaPackageExecute(r)
}

/*
GetImageContentByTypeJavaPackage Get the content of an image by type java

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageContentByTypeJavaPackageRequest
*/
func (a *ImagesApiService) GetImageContentByTypeJavaPackage(ctx context.Context, imageDigest string) ApiGetImageContentByTypeJavaPackageRequest {
	return ApiGetImageContentByTypeJavaPackageRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return ContentJavaPackageResponse
func (a *ImagesApiService) GetImageContentByTypeJavaPackageExecute(r ApiGetImageContentByTypeJavaPackageRequest) (*ContentJavaPackageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentJavaPackageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageContentByTypeJavaPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content/java"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageContentByTypeMalwareRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageContentByTypeMalwareRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageContentByTypeMalwareRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageContentByTypeMalwareRequest) Execute() (*ContentMalwareResponse, *http.Response, error) {
	return r.ApiService.GetImageContentByTypeMalwareExecute(r)
}

/*
GetImageContentByTypeMalware Get the content of an image by type malware

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageContentByTypeMalwareRequest
*/
func (a *ImagesApiService) GetImageContentByTypeMalware(ctx context.Context, imageDigest string) ApiGetImageContentByTypeMalwareRequest {
	return ApiGetImageContentByTypeMalwareRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return ContentMalwareResponse
func (a *ImagesApiService) GetImageContentByTypeMalwareExecute(r ApiGetImageContentByTypeMalwareRequest) (*ContentMalwareResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentMalwareResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageContentByTypeMalware")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content/malware"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageContentSummaryRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageContentSummaryRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageContentSummaryRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageContentSummaryRequest) Execute() (*ImageContentSummary, *http.Response, error) {
	return r.ApiService.GetImageContentSummaryExecute(r)
}

/*
GetImageContentSummary Get image content summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageContentSummaryRequest
*/
func (a *ImagesApiService) GetImageContentSummary(ctx context.Context, imageDigest string) ApiGetImageContentSummaryRequest {
	return ApiGetImageContentSummaryRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return ImageContentSummary
func (a *ImagesApiService) GetImageContentSummaryExecute(r ApiGetImageContentSummaryRequest) (*ImageContentSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageContentSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageContentSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageMetadataByTypeRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	metadataType string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageMetadataByTypeRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageMetadataByTypeRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageMetadataByTypeRequest) Execute() (*MetadataResponse, *http.Response, error) {
	return r.ApiService.GetImageMetadataByTypeExecute(r)
}

/*
GetImageMetadataByType Get the metadata of an image by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @param metadataType
 @return ApiGetImageMetadataByTypeRequest
*/
func (a *ImagesApiService) GetImageMetadataByType(ctx context.Context, imageDigest string, metadataType string) ApiGetImageMetadataByTypeRequest {
	return ApiGetImageMetadataByTypeRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
		metadataType: metadataType,
	}
}

// Execute executes the request
//  @return MetadataResponse
func (a *ImagesApiService) GetImageMetadataByTypeExecute(r ApiGetImageMetadataByTypeRequest) (*MetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageMetadataByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/metadata/{metadata_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_type"+"}", url.PathEscape(parameterValueToString(r.metadataType, "metadataType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImagePolicyCheckByDigestRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	tag *string
	policyId *string
	detail *bool
	history *bool
	interactive *bool
	baseDigest *string
	xAnchoreAccount *string
}

func (r ApiGetImagePolicyCheckByDigestRequest) Tag(tag string) ApiGetImagePolicyCheckByDigestRequest {
	r.tag = &tag
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) PolicyId(policyId string) ApiGetImagePolicyCheckByDigestRequest {
	r.policyId = &policyId
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) Detail(detail bool) ApiGetImagePolicyCheckByDigestRequest {
	r.detail = &detail
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) History(history bool) ApiGetImagePolicyCheckByDigestRequest {
	r.history = &history
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) Interactive(interactive bool) ApiGetImagePolicyCheckByDigestRequest {
	r.interactive = &interactive
	return r
}

// Digest of a base image. If specified the evaluation will indicate results inherited from the base image. Can specify \&quot;auto\&quot; to have the base image automatically calculated.
func (r ApiGetImagePolicyCheckByDigestRequest) BaseDigest(baseDigest string) ApiGetImagePolicyCheckByDigestRequest {
	r.baseDigest = &baseDigest
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImagePolicyCheckByDigestRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImagePolicyCheckByDigestRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImagePolicyCheckByDigestRequest) Execute() (*PolicyEvaluation, *http.Response, error) {
	return r.ApiService.GetImagePolicyCheckByDigestExecute(r)
}

/*
GetImagePolicyCheckByDigest Check policy evaluation status for image

Get the policy evaluation for the given image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImagePolicyCheckByDigestRequest
*/
func (a *ImagesApiService) GetImagePolicyCheckByDigest(ctx context.Context, imageDigest string) ApiGetImagePolicyCheckByDigestRequest {
	return ApiGetImagePolicyCheckByDigestRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return PolicyEvaluation
func (a *ImagesApiService) GetImagePolicyCheckByDigestExecute(r ApiGetImagePolicyCheckByDigestRequest) (*PolicyEvaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyEvaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImagePolicyCheckByDigest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	if r.policyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id", r.policyId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	if r.detail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detail", r.detail, "form", "")
	} else {
		var defaultValue bool = true
		r.detail = &defaultValue
	}
	if r.history != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "history", r.history, "form", "")
	} else {
		var defaultValue bool = false
		r.history = &defaultValue
	}
	if r.interactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interactive", r.interactive, "form", "")
	} else {
		var defaultValue bool = false
		r.interactive = &defaultValue
	}
	if r.baseDigest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_digest", r.baseDigest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageSbomCyclonedxJsonRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageSbomCyclonedxJsonRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageSbomCyclonedxJsonRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageSbomCyclonedxJsonRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetImageSbomCyclonedxJsonExecute(r)
}

/*
GetImageSbomCyclonedxJson Get image sbom in the CycloneDX format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageSbomCyclonedxJsonRequest
*/
func (a *ImagesApiService) GetImageSbomCyclonedxJson(ctx context.Context, imageDigest string) ApiGetImageSbomCyclonedxJsonRequest {
	return ApiGetImageSbomCyclonedxJsonRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return string
func (a *ImagesApiService) GetImageSbomCyclonedxJsonExecute(r ApiGetImageSbomCyclonedxJsonRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageSbomCyclonedxJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/sboms/cyclonedx-json"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageSbomNativeJsonRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageSbomNativeJsonRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageSbomNativeJsonRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageSbomNativeJsonRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetImageSbomNativeJsonExecute(r)
}

/*
GetImageSbomNativeJson Get image sbom in the native Anchore format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageSbomNativeJsonRequest
*/
func (a *ImagesApiService) GetImageSbomNativeJson(ctx context.Context, imageDigest string) ApiGetImageSbomNativeJsonRequest {
	return ApiGetImageSbomNativeJsonRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return string
func (a *ImagesApiService) GetImageSbomNativeJsonExecute(r ApiGetImageSbomNativeJsonRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageSbomNativeJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/sboms/native-json"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageSbomSpdxJsonRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageSbomSpdxJsonRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageSbomSpdxJsonRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageSbomSpdxJsonRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetImageSbomSpdxJsonExecute(r)
}

/*
GetImageSbomSpdxJson Get image sbom in the SPDX format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageSbomSpdxJsonRequest
*/
func (a *ImagesApiService) GetImageSbomSpdxJson(ctx context.Context, imageDigest string) ApiGetImageSbomSpdxJsonRequest {
	return ApiGetImageSbomSpdxJsonRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return string
func (a *ImagesApiService) GetImageSbomSpdxJsonExecute(r ApiGetImageSbomSpdxJsonRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageSbomSpdxJson")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/sboms/spdx-json"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageVulnerabilitiesByDigestRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	vulnType string
	forceRefresh *bool
	includeVulnDescription *bool
	vendorOnly *bool
	baseDigest *string
	xAnchoreAccount *string
}

func (r ApiGetImageVulnerabilitiesByDigestRequest) ForceRefresh(forceRefresh bool) ApiGetImageVulnerabilitiesByDigestRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiGetImageVulnerabilitiesByDigestRequest) IncludeVulnDescription(includeVulnDescription bool) ApiGetImageVulnerabilitiesByDigestRequest {
	r.includeVulnDescription = &includeVulnDescription
	return r
}

// Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data. When set to true, it will filter out all vulnerabilities where &#x60;will_not_fix&#x60; is False. If false all vulnerabilities are returned regardless of &#x60;will_not_fix&#x60;
func (r ApiGetImageVulnerabilitiesByDigestRequest) VendorOnly(vendorOnly bool) ApiGetImageVulnerabilitiesByDigestRequest {
	r.vendorOnly = &vendorOnly
	return r
}

// Digest of a base image. If specified the vulnerabilities will indicate inheritance from the base image. Can specify \&quot;auto\&quot; to have the base image automatically calculated.
func (r ApiGetImageVulnerabilitiesByDigestRequest) BaseDigest(baseDigest string) ApiGetImageVulnerabilitiesByDigestRequest {
	r.baseDigest = &baseDigest
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageVulnerabilitiesByDigestRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageVulnerabilitiesByDigestRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageVulnerabilitiesByDigestRequest) Execute() (*ImagePackageVulnerabilityResponse, *http.Response, error) {
	return r.ApiService.GetImageVulnerabilitiesByDigestExecute(r)
}

/*
GetImageVulnerabilitiesByDigest Get vulnerabilities by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @param vulnType
 @return ApiGetImageVulnerabilitiesByDigestRequest
*/
func (a *ImagesApiService) GetImageVulnerabilitiesByDigest(ctx context.Context, imageDigest string, vulnType string) ApiGetImageVulnerabilitiesByDigestRequest {
	return ApiGetImageVulnerabilitiesByDigestRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
		vulnType: vulnType,
	}
}

// Execute executes the request
//  @return ImagePackageVulnerabilityResponse
func (a *ImagesApiService) GetImageVulnerabilitiesByDigestExecute(r ApiGetImageVulnerabilitiesByDigestRequest) (*ImagePackageVulnerabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImagePackageVulnerabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageVulnerabilitiesByDigest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/vuln/{vuln_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vuln_type"+"}", url.PathEscape(parameterValueToString(r.vulnType, "vulnType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceRefresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force_refresh", r.forceRefresh, "form", "")
	} else {
		var defaultValue bool = false
		r.forceRefresh = &defaultValue
	}
	if r.includeVulnDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_vuln_description", r.includeVulnDescription, "form", "")
	} else {
		var defaultValue bool = false
		r.includeVulnDescription = &defaultValue
	}
	if r.vendorOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendor_only", r.vendorOnly, "form", "")
	} else {
		var defaultValue bool = true
		r.vendorOnly = &defaultValue
	}
	if r.baseDigest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_digest", r.baseDigest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetImageVulnerabilityTypesRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiGetImageVulnerabilityTypesRequest) XAnchoreAccount(xAnchoreAccount string) ApiGetImageVulnerabilityTypesRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiGetImageVulnerabilityTypesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetImageVulnerabilityTypesExecute(r)
}

/*
GetImageVulnerabilityTypes Get vulnerability types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiGetImageVulnerabilityTypesRequest
*/
func (a *ImagesApiService) GetImageVulnerabilityTypes(ctx context.Context, imageDigest string) ApiGetImageVulnerabilityTypesRequest {
	return ApiGetImageVulnerabilityTypesRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []string
func (a *ImagesApiService) GetImageVulnerabilityTypesExecute(r ApiGetImageVulnerabilityTypesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.GetImageVulnerabilityTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/vuln"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFileContentSearchResultsRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
}

func (r ApiListFileContentSearchResultsRequest) Execute() ([]FileContentSearchResult, *http.Response, error) {
	return r.ApiService.ListFileContentSearchResultsExecute(r)
}

/*
ListFileContentSearchResults Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListFileContentSearchResultsRequest
*/
func (a *ImagesApiService) ListFileContentSearchResults(ctx context.Context, imageDigest string) ApiListFileContentSearchResultsRequest {
	return ApiListFileContentSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []FileContentSearchResult
func (a *ImagesApiService) ListFileContentSearchResultsExecute(r ApiListFileContentSearchResultsRequest) ([]FileContentSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FileContentSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListFileContentSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/file-content-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListImageContentRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiListImageContentRequest) XAnchoreAccount(xAnchoreAccount string) ApiListImageContentRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiListImageContentRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ListImageContentExecute(r)
}

/*
ListImageContent List image content types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListImageContentRequest
*/
func (a *ImagesApiService) ListImageContent(ctx context.Context, imageDigest string) ApiListImageContentRequest {
	return ApiListImageContentRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []string
func (a *ImagesApiService) ListImageContentExecute(r ApiListImageContentRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListImageContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListImageMetadataRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
	xAnchoreAccount *string
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiListImageMetadataRequest) XAnchoreAccount(xAnchoreAccount string) ApiListImageMetadataRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiListImageMetadataRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ListImageMetadataExecute(r)
}

/*
ListImageMetadata List image metadata types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListImageMetadataRequest
*/
func (a *ImagesApiService) ListImageMetadata(ctx context.Context, imageDigest string) ApiListImageMetadataRequest {
	return ApiListImageMetadataRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []string
func (a *ImagesApiService) ListImageMetadataExecute(r ApiListImageMetadataRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListImageMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListImagesRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageId *string
	history *bool
	fullTag *string
	imageStatus *string
	analysisStatus *string
	analyzedSince *string
	xAnchoreAccount *string
}

// Filter results matching image ID
func (r ApiListImagesRequest) ImageId(imageId string) ApiListImagesRequest {
	r.imageId = &imageId
	return r
}

// Include image history in the response
func (r ApiListImagesRequest) History(history bool) ApiListImagesRequest {
	r.history = &history
	return r
}

// Full docker-pull string to filter results by (e.g. docker.io/library/nginx:latest, or myhost.com:5000/testimages:v1.1.1)
func (r ApiListImagesRequest) FullTag(fullTag string) ApiListImagesRequest {
	r.fullTag = &fullTag
	return r
}

// Filter by image_status value on the record. Default if omitted is &#39;active&#39;.
func (r ApiListImagesRequest) ImageStatus(imageStatus string) ApiListImagesRequest {
	r.imageStatus = &imageStatus
	return r
}

// Filter by analysis_status value on the record.
func (r ApiListImagesRequest) AnalysisStatus(analysisStatus string) ApiListImagesRequest {
	r.analysisStatus = &analysisStatus
	return r
}

// Filter by images analyzed on or after the specified datetime
func (r ApiListImagesRequest) AnalyzedSince(analyzedSince string) ApiListImagesRequest {
	r.analyzedSince = &analyzedSince
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiListImagesRequest) XAnchoreAccount(xAnchoreAccount string) ApiListImagesRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiListImagesRequest) Execute() (*AnchoreImageList, *http.Response, error) {
	return r.ApiService.ListImagesExecute(r)
}

/*
ListImages List all visible images

List all images visible to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListImagesRequest
*/
func (a *ImagesApiService) ListImages(ctx context.Context) ApiListImagesRequest {
	return ApiListImagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnchoreImageList
func (a *ImagesApiService) ListImagesExecute(r ApiListImagesRequest) (*AnchoreImageList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnchoreImageList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_id", r.imageId, "form", "")
	}
	if r.history != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "history", r.history, "form", "")
	}
	if r.fullTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_tag", r.fullTag, "form", "")
	}
	if r.imageStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_status", r.imageStatus, "form", "")
	} else {
		var defaultValue string = "active"
		r.imageStatus = &defaultValue
	}
	if r.analysisStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analysis_status", r.analysisStatus, "form", "")
	}
	if r.analyzedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzed_since", r.analyzedSince, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRetrievedFilesRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
}

func (r ApiListRetrievedFilesRequest) Execute() ([]RetrievedFile, *http.Response, error) {
	return r.ApiService.ListRetrievedFilesExecute(r)
}

/*
ListRetrievedFiles Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListRetrievedFilesRequest
*/
func (a *ImagesApiService) ListRetrievedFiles(ctx context.Context, imageDigest string) ApiListRetrievedFilesRequest {
	return ApiListRetrievedFilesRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []RetrievedFile
func (a *ImagesApiService) ListRetrievedFilesExecute(r ApiListRetrievedFilesRequest) ([]RetrievedFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RetrievedFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListRetrievedFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/retrieved-files"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSecretSearchResultsRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageDigest string
}

func (r ApiListSecretSearchResultsRequest) Execute() ([]SecretSearchResult, *http.Response, error) {
	return r.ApiService.ListSecretSearchResultsExecute(r)
}

/*
ListSecretSearchResults Return a list of analyzer artifacts of the specified type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param imageDigest
 @return ApiListSecretSearchResultsRequest
*/
func (a *ImagesApiService) ListSecretSearchResults(ctx context.Context, imageDigest string) ApiListSecretSearchResultsRequest {
	return ApiListSecretSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
		imageDigest: imageDigest,
	}
}

// Execute executes the request
//  @return []SecretSearchResult
func (a *ImagesApiService) ListSecretSearchResultsExecute(r ApiListSecretSearchResultsRequest) ([]SecretSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SecretSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.ListSecretSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images/{image_digest}/artifacts/secret-search"
	localVarPath = strings.Replace(localVarPath, "{"+"image_digest"+"}", url.PathEscape(parameterValueToString(r.imageDigest, "imageDigest")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSummaryImageCountsRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageStatus *[]string
	registry *string
	repo *string
	xAnchoreAccount *string
}

// Filter images in one or more states such as active, deleting. Defaults to active images only if unspecified
func (r ApiSummaryImageCountsRequest) ImageStatus(imageStatus []string) ApiSummaryImageCountsRequest {
	r.imageStatus = &imageStatus
	return r
}

// Filter by registry
func (r ApiSummaryImageCountsRequest) Registry(registry string) ApiSummaryImageCountsRequest {
	r.registry = &registry
	return r
}

// Filter by repo
func (r ApiSummaryImageCountsRequest) Repo(repo string) ApiSummaryImageCountsRequest {
	r.repo = &repo
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiSummaryImageCountsRequest) XAnchoreAccount(xAnchoreAccount string) ApiSummaryImageCountsRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiSummaryImageCountsRequest) Execute() (*AnchoreImageSummaryCounts, *http.Response, error) {
	return r.ApiService.SummaryImageCountsExecute(r)
}

/*
SummaryImageCounts Image summary counts

Count tags and images by analysis status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummaryImageCountsRequest
*/
func (a *ImagesApiService) SummaryImageCounts(ctx context.Context) ApiSummaryImageCountsRequest {
	return ApiSummaryImageCountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnchoreImageSummaryCounts
func (a *ImagesApiService) SummaryImageCountsExecute(r ApiSummaryImageCountsRequest) (*AnchoreImageSummaryCounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnchoreImageSummaryCounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.SummaryImageCounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summaries/image-counts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_status", r.imageStatus, "form", "csv")
	} else {
		defaultValue := []string{"active"}
		r.imageStatus = &defaultValue
	}
	if r.registry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "registry", r.registry, "form", "")
	}
	if r.repo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repo", r.repo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSummaryImageTagsRequest struct {
	ctx context.Context
	ApiService ImagesApi
	imageStatus *[]string
	analysisStatus *[]string
	analyzedSince *string
	registry *string
	repository *string
	tag *string
	runtime *bool
	orderBy *[]string
	orderByDescending *[]bool
	filter *string
	limit *int32
	page *int32
	xAnchoreAccount *string
}

// Filter images in one or more states such as active, deleting. Defaults to active images only if unspecified
func (r ApiSummaryImageTagsRequest) ImageStatus(imageStatus []string) ApiSummaryImageTagsRequest {
	r.imageStatus = &imageStatus
	return r
}

// Filter images in one or more analysis_status such as analyzed, not_analyzed, analysis_failed. Defaults to unfiltered if unspecified
func (r ApiSummaryImageTagsRequest) AnalysisStatus(analysisStatus []string) ApiSummaryImageTagsRequest {
	r.analysisStatus = &analysisStatus
	return r
}

// Filter images analyzed on or after the specified datetime
func (r ApiSummaryImageTagsRequest) AnalyzedSince(analyzedSince string) ApiSummaryImageTagsRequest {
	r.analyzedSince = &analyzedSince
	return r
}

// A registry name to filter result by (e.g. \&quot;docker.io\&quot;)
func (r ApiSummaryImageTagsRequest) Registry(registry string) ApiSummaryImageTagsRequest {
	r.registry = &registry
	return r
}

// A repository name to filter results by (e.g. \&quot;jboss/keycloak\&quot;)
func (r ApiSummaryImageTagsRequest) Repository(repository string) ApiSummaryImageTagsRequest {
	r.repository = &repository
	return r
}

// A tag value to filter results by (e.g. \&quot;latest\&quot;, or \&quot;v1.2.0\&quot;)
func (r ApiSummaryImageTagsRequest) Tag(tag string) ApiSummaryImageTagsRequest {
	r.tag = &tag
	return r
}

// Filter by images with runtime inventory
func (r ApiSummaryImageTagsRequest) Runtime(runtime bool) ApiSummaryImageTagsRequest {
	r.runtime = &runtime
	return r
}

// List of field name(s) to order by, ascending by default
func (r ApiSummaryImageTagsRequest) OrderBy(orderBy []string) ApiSummaryImageTagsRequest {
	r.orderBy = &orderBy
	return r
}

// Configures the sort order of each specified order_by column to be descending (true) instead of ascending (false)
func (r ApiSummaryImageTagsRequest) OrderByDescending(orderByDescending []bool) ApiSummaryImageTagsRequest {
	r.orderByDescending = &orderByDescending
	return r
}

// Filter by &#39;image_digest&#39; or &#39;full_tag&#39; fields, using partial or full string match
func (r ApiSummaryImageTagsRequest) Filter(filter string) ApiSummaryImageTagsRequest {
	r.filter = &filter
	return r
}

// Maximum number of rows to return
func (r ApiSummaryImageTagsRequest) Limit(limit int32) ApiSummaryImageTagsRequest {
	r.limit = &limit
	return r
}

// Page number to return, one&#39;s based
func (r ApiSummaryImageTagsRequest) Page(page int32) ApiSummaryImageTagsRequest {
	r.page = &page
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiSummaryImageTagsRequest) XAnchoreAccount(xAnchoreAccount string) ApiSummaryImageTagsRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiSummaryImageTagsRequest) Execute() (*AnchoreImageTagSummaryList, *http.Response, error) {
	return r.ApiService.SummaryImageTagsExecute(r)
}

/*
SummaryImageTags Summarize image tags

List all image tags visible to the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummaryImageTagsRequest
*/
func (a *ImagesApiService) SummaryImageTags(ctx context.Context) ApiSummaryImageTagsRequest {
	return ApiSummaryImageTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnchoreImageTagSummaryList
func (a *ImagesApiService) SummaryImageTagsExecute(r ApiSummaryImageTagsRequest) (*AnchoreImageTagSummaryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnchoreImageTagSummaryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.SummaryImageTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summaries/image-tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_status", r.imageStatus, "form", "csv")
	} else {
		defaultValue := []string{"active"}
		r.imageStatus = &defaultValue
	}
	if r.analysisStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analysis_status", r.analysisStatus, "form", "csv")
	} else {
		defaultValue := []string{"all"}
		r.analysisStatus = &defaultValue
	}
	if r.analyzedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "analyzed_since", r.analyzedSince, "form", "")
	}
	if r.registry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "registry", r.registry, "form", "")
	}
	if r.repository != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repository", r.repository, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.runtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime", r.runtime, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "csv")
	}
	if r.orderByDescending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by_descending", r.orderByDescending, "form", "csv")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
