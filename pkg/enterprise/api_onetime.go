/*
Anchore API

This is the Anchore API. Provides the external API for users of Anchore Enterprise.

API version: 2.11.1
Contact: dev@anchore.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package enterprise

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type OnetimeAPI interface {

	/*
	StatelessScan Return a onetime evaluation of the provided data.

	Use this operation for checking sboms for vulnerabilities and policy evaluations in cases where the sbom does not need to be stored for later re-scans or added to the managed set of SBOMs in Anchore. If you need to upload and save an SBOM use the "/import/*" API set instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStatelessScanRequest
	*/
	StatelessScan(ctx context.Context) ApiStatelessScanRequest

	// StatelessScanExecute executes the request
	//  @return ScanResponse
	StatelessScanExecute(r ApiStatelessScanRequest) (*ScanResponse, *http.Response, error)
}

// OnetimeAPIService OnetimeAPI service
type OnetimeAPIService service

type ApiStatelessScanRequest struct {
	ctx context.Context
	ApiService OnetimeAPI
	tag *string
	scanRequest *ScanRequest
	xAnchoreAccount *string
	policyId *string
}

func (r ApiStatelessScanRequest) Tag(tag string) ApiStatelessScanRequest {
	r.tag = &tag
	return r
}

func (r ApiStatelessScanRequest) ScanRequest(scanRequest ScanRequest) ApiStatelessScanRequest {
	r.scanRequest = &scanRequest
	return r
}

// An account name to change the resource scope of the request to that account, if permissions allow (admin only)
func (r ApiStatelessScanRequest) XAnchoreAccount(xAnchoreAccount string) ApiStatelessScanRequest {
	r.xAnchoreAccount = &xAnchoreAccount
	return r
}

func (r ApiStatelessScanRequest) PolicyId(policyId string) ApiStatelessScanRequest {
	r.policyId = &policyId
	return r
}

func (r ApiStatelessScanRequest) Execute() (*ScanResponse, *http.Response, error) {
	return r.ApiService.StatelessScanExecute(r)
}

/*
StatelessScan Return a onetime evaluation of the provided data.

Use this operation for checking sboms for vulnerabilities and policy evaluations in cases where the sbom does not need to be stored for later re-scans or added to the managed set of SBOMs in Anchore. If you need to upload and save an SBOM use the "/import/*" API set instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStatelessScanRequest
*/
func (a *OnetimeAPIService) StatelessScan(ctx context.Context) ApiStatelessScanRequest {
	return ApiStatelessScanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScanResponse
func (a *OnetimeAPIService) StatelessScanExecute(r ApiStatelessScanRequest) (*ScanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OnetimeAPIService.StatelessScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}
	if r.scanRequest == nil {
		return localVarReturnValue, nil, reportError("scanRequest is required and must be specified")
	}

	if r.policyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id", r.policyId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAnchoreAccount != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-anchore-account", r.xAnchoreAccount, "simple", "")
	}
	// body params
	localVarPostBody = r.scanRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
